<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React学习指南</title>
      <link href="/2024/06/02/React%20%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
      <url>/2024/06/02/React%20%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1>React 学习指南</h1><h2 id="初学者看这里">初学者看这里</h2><h3 id="引子：React-与-Hyperapp">引子：React 与 Hyperapp</h3><p>React 是 Facebook 于 2013 年开源的 JS 库，用于构建用户界面。这也是目前前端界最流行的 UI 基础库。</p><p>我们首先让大家接触 Hyperapp ，而不是直接学 React，就是因为 React 本身的设计思想，其实很简单。就是 UI = f(state)。而 Hyperapp 就是基于这个思想设计的简化版 React。</p><p>所以 React 相比 Hyperapp，更强大，适合真正的生产级别应用。但核心思想其实是一致的。懂了 Hyperapp，你可以很快上手 React。</p><p>React 的组件也是一个函数（React 16 之前只支持 Class 组件，不过目前我们一般都使用 React 16+，可以全盘使用函数式组件）。函数返回的是 JSX 表示的虚拟 DOM 节点树，和 Hyperapp 一致。</p><p>但相比 Hyperapp，React 的每个组件都可以有自己的状态，而不是只有顶层的 App 才存储状态。</p><blockquote><p>React 可以通过 Redux 这样的状态管理工具去拥有全局状态，组件局部状态和全局状态可以混合使用。Redux 同样和 Hyperapp 的状态管理有相似之处。</p></blockquote><p>React 在函数式组件中的局部状态和副作用，是通过 Hook 来实现的。本身单纯的函数式组件是没有状态，也不能产生副作用的（比如发送网络请求），Hook 的出现改变了这一点。目前我们可以不用了解 Hook 具体的原理，只要掌握 Hook 的使用即可。</p><p>让我们来看一个简单的例子：</p><pre><code class="language-jsx">import React, &#123; useState &#125; from &quot;react&quot;;function Example() &#123;const [count, setCount] = useState(0);return (&lt;div&gt;&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;&lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt;&lt;/div&gt;);&#125;</code></pre><p>Codepen 实例</p><p><code>useState</code> 是用于获取状态的 Hook。Hook 其实就是普通的函数调用。<code>useState</code> 调用之后会返回一个数组，第一项是状态的值，第二项是一个用来修改状态的函数。</p><p>我们只要记住，每次组件被调用，组件（函数）就会执行，然后 <code>useState</code> 就会被调用。调用之后就可以拿到最新的状态。</p><p>通过这个例子，我们就可以实现一个计数器，需要注意的是，React 的事件回调属性是驼峰的形式，并且回调只是普通的函数，里面可以执行任意逻辑，无需像 Hyperapp 那样返回新的 state。</p><p>此外 React 比起 Hyperapp 还有一些核心功能</p><ul class="lvl-0"><li class="lvl-2"><p>支持合成事件，抹平了不同浏览器的事件兼容性</p></li><li class="lvl-2"><p>内置了调度系统，会根据情况安排最合适的渲染时机，避免卡顿</p></li><li class="lvl-2"><p>使用 fiber 架构，可以把组件的渲染工作拆分到多次完成，避免卡顿</p></li><li class="lvl-2"><p>支持跨端，可以通过 React-native 编写 安卓/iOS/Web 三段通用的 App</p></li><li class="lvl-2"><p>Context，Ref，Suspense，Fragment，Portal，各种 Hooks 等等多种多样的 API</p></li></ul><h3 id="学习材料推荐">学习材料推荐</h3><p>学 React 之前需要明确一点，React 在 16.8 版本推出了 Hooks。Hooks 让函数式组件可以拥有状态和副作用，而函数式组件相比 Class 组件更符合 UI = f(state) 的理念。因此目前我们编写的组件，都是用 Hooks 实现的。</p><p>但官网上的教程，大部分都是以 Class 组件为基础的。所以目前还没法避免接触 Class 组件，以后在历史项目中也可能会遇到。Class 组件其实也不难学。但大家要把重心放到函数组件上。</p><p>首先要看官方文档，这是免不了的。首先是 <a href="https://reactjs.org/docs/hello-world.html">Main Concepts</a>。</p><ol><li class="lvl-3"><p>了解基础： Props，State，组件定义，Class 组件声明周期，事件监听。</p></li><li class="lvl-3"><p>了解如何编写条件渲染，列表渲染，关注 key 的作用。</p></li><li class="lvl-3"><p>特别要关注：状态提升（Lifting State Up），组合 vs 继承（Composition vs Inheritance），受控组件 vs 非受控组件（Controlled Components vs Uncontrolled Components）</p></li></ol><p>然后是 Hooks，看官方的 <a href="https://reactjs.org/docs/hooks-intro.html">Hooks 教程</a>。useState 和 useEffect 是必须掌握的，其他的可以浏览一下。</p><p>之后就可以看一本完整的小册：<a href="https://leanpub.com/the-road-to-learn-react-chinese/">The Way To React</a>。</p><blockquote><p>这本书是免费的，把价格拖到 0 就行。如果下载有问题，可以在组群反馈。</p></blockquote><p>这本书的食用方式：</p><ul class="lvl-0"><li class="lvl-2"><p>这本书用一个 Hacker News 程序员论坛的例子，贯穿全书，每一节后面都有源码链接，是在线的，可以看当前章节完成之后书本例子的代码。一定要结合代码看，最好可以自己在本地起一个项目，跟着写。</p></li><li class="lvl-2"><p>每章结束后会有一些链接，主要是章节里提到的 JS 知识点，如果觉得有不懂的 JS 知识点，不妨先停下来复习一下。</p></li></ul><h3 id="小练习">小练习</h3><p>将 Class 组件实现的 <a href="https://reactjs.org/tutorial/tutorial.html">React 官方教程</a> 改造为函数式组件（Hooks）版本。新建仓库 react-tutorial-hooks 并上传到 Github。</p><h2 id="进阶内容">进阶内容</h2><ul class="lvl-0"><li class="lvl-2"><p>受控 vs 非受控</p></li><li class="lvl-2"><p>Advanced Topics</p></li><li class="lvl-2"><p>ErrorBoundary</p></li><li class="lvl-2"><p>设计模式：HOC + renderProps</p></li><li class="lvl-2"><p>自定义 Hooks</p></li><li class="lvl-2"><p>Suspense</p></li><li class="lvl-2"><p>cocurrent</p></li><li class="lvl-2"><p>rsc</p></li></ul><h3 id="受控vs非受控">受控vs非受控</h3><h4 id="受控组件">受控组件</h4><p>受控组件，指的是将表单元素的值交给组件的 state 来保存。</p><p>例子：</p><pre><code class="language-jsx">// import './styles.css'import &#123; useState &#125; from 'react'const App = () =&gt; &#123;  const [val, setVal] = useState('muxi')  const sumbit = () =&gt; &#123;    // 直接拿组件 state    const username = val    // ...  &#125;  return (    &lt;div&gt;      用户名：      &lt;input        value=&#123;val&#125;        onInput=&#123;(e) =&gt; &#123;          setVal(e.target.value)        &#125;&#125;      /&gt;      ...    &lt;/div&gt;  )&#125;export default App;</code></pre><p>我们用 value prop 控制着 input 元素的值，当发生输入事件时，我们将新值赋值给 val，然后 val 再通过 value 强制更新到 input。</p><p>这种写法，可以<strong>让 state 一直保持和 input 的内容相同，我们可以直接读取 state，将其传递给其他地方，比如通过 redux 去传递。</strong></p><p><strong>缺点是会进行组件的更新，一般来说表单元素并不复杂，重渲染成本不高，可以忽略不计。</strong></p><h4 id="非受控组件">非受控组件</h4><p>非受控，就是指状态不由组件的 state 把持，而是让表单元素的内部控制着状态，在我们需要的时候再通过 <code>element.value</code> 的方式取出。</p><p>表单元素的初始值通过 defaultValue prop 来设置。</p><p>例子：</p><pre><code class="language-jsx">const App = () =&gt; &#123;  const ref = useRef(null)  const sumbit = () =&gt; &#123;    // 通过元素的引用取值    const username = ref.current?.value    // ...  &#125;  return (    &lt;div&gt;      用户名：      &lt;input ref=&#123;ref&#125; defaultValue=&quot;muxi&quot; /&gt;      ...    &lt;/div&gt;  )&#125;</code></pre><p>优点是不会更新组件。缺点是不方便实时将值传给其他组件。</p><p>另外，它适合一种延迟更新状态的场景。比如输入一些内容，回车后失焦，发现格式不合法，就恢复为上一次的值。</p><h3 id="Advanced-Topics">Advanced Topics</h3><p>Advanced Topics，也就是一些高级的、不天天用的，但是需要我们会的一些知识点。</p><p><a href="https://reactresources.com/topics/advanced-concepts">Advanced React Concepts | React Resources</a> 给出的Advanced Concepts:</p><ul class="lvl-0"><li class="lvl-2"><p>Advanced Concepts</p><ul class="lvl-2"><li class="lvl-4"><a href="https://reactresources.com/topics/context">Context</a></li><li class="lvl-4"><a href="https://reactresources.com/topics/error-boundaries">Error Boundaries</a></li><li class="lvl-4"><a href="https://reactresources.com/topics/portals">Portals</a></li><li class="lvl-4"><a href="https://reactresources.com/topics/higher-order-components">Higher Order Components</a></li><li class="lvl-4"><a href="https://reactresources.com/topics/render-props">Render Props</a></li><li class="lvl-4">Concurrent Rendering<ul class="lvl-4"><li class="lvl-6"><a href="https://reactresources.com/topics/time-slicing">Time Slicing</a></li><li class="lvl-6"><a href="https://reactresources.com/topics/suspense">Suspense</a></li></ul></li><li class="lvl-4"><a href="https://reactresources.com/topics/hooks">Hooks</a></li></ul></li></ul><h3 id="ErrorBoundary">ErrorBoundary</h3><h4 id="使用错误边界捕获渲染错误">使用错误边界捕获渲染错误</h4><p>React 中的错误边界是 <a href="https://blog.logrocket.com/handling-javascript-errors-react-error-boundaries/">React 应用程序中错误处理的一个关键方面</a>。它们是 React 组件，用于捕获其子组件树中任何位置的 JavaScript 错误，记录这些错误，并显示回退 UI，而不是崩溃的组件树。它们就像一个 JavaScript 块，但用于组件。</p><p>React v16 中引入了错误边界，要使用它们，需要使用以下一种或两种<a href="https://blog.logrocket.com/react-lifecycle-methods-tutorial-examples/">生命周期方法</a>定义类组件：</p><ul class="lvl-0"><li class="lvl-2"><p><code>getDerivedStateFromError()</code>：此生命周期方法在引发错误后呈现回退 UI。它是在渲染阶段调用的，因此不允许产生副作用</p></li><li class="lvl-2"><p><code>componentDidCatch()</code>：此方法用于记录错误信息。它是在提交阶段调用的，因此允许副作用</p></li></ul><pre><code class="language-jsx">class ErrorBoundary extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; hasError: false &#125;;  &#125;  static getDerivedStateFromError(error) &#123;    // Update state so the next render will show the fallback UI.    return &#123; hasError: true &#125;;  &#125;  componentDidCatch(error, errorInfo) &#123;    // You can also log the error to an error reporting service    console.log(error, errorInfo);  &#125;  render() &#123;    if (this.state.hasError) &#123;      // You can render any custom fallback UI      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;    &#125;    return this.props.children; //当没有错误发生时，正常渲染子组件  &#125;&#125;// Usage in a componentclass App extends React.Component &#123;  render() &#123;    return (      &lt;ErrorBoundary&gt;        &lt;MyComponent /&gt;      &lt;/ErrorBoundary&gt;    );  &#125;&#125;</code></pre><pre><code class="language-jsx">//MyComponentclass MyComponent extends React.Component &#123;  render() &#123;    const dangerousOperation = null; // 故意设置为null以触发错误    // 直接调用一个可能不存在的方法，这将在渲染时抛出错误    dangerousOperation.doSomething();    return (      &lt;div&gt;        &lt;h2&gt;My Component&lt;/h2&gt;        &lt;p&gt;This is an example of a component that might error.&lt;/p&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><h4 id="使用-react-error-boundary">使用 react-error-boundary</h4><p>虽然类组件及其生命周期方法可以帮助我们实现错误边界，但 <a href="https://github.com/bvaughn/react-error-boundary">react-error-boundary</a> 是一个将此功能提升到新水平的库，使该过程更加简单和用户友好。这是一个小型库，提供了一种灵活的方式来处理 React 组件中的 JavaScript 错误。</p><p><strong>如何下载？</strong></p><pre><code>npm install react-error-boundary</code></pre><p>React-error-boundary 使用更现代的方法与 <a href="https://blog.logrocket.com/react-hooks-cheat-sheet-solutions-common-problems/">React Hooks</a> 和功能组件，这更符合 React 开发的当前趋势。它使用一个名为<code>ErrorBoundary</code>的简单组件，您可以使用该组件来包装可能容易出错的代码。</p><p>该库提供的组件有一个名为 <code>fallbackRender</code> 的 prop，它接受一个函数或一个 React 元素，以便在捕获错误时显示。此外，它还提供了一个道具，可用于在某些道具更改时重置组件的状态。<code>ErrorBoundary``fallbackUI``resetKeys</code></p><p>react-error-boundary 的美妙之处在于它消除了手动编写类组件和处理状态的需要。它在幕后完成所有繁重的工作，使开发人员能够专注于构建他们的应用程序。让我们看一个如何在组件中使用 react-error-boundary 的例子：</p><pre><code class="language-jsx">import &#123; ErrorBoundary &#125; from 'react-error-boundary'function MyFallbackComponent(&#123; error, resetErrorBoundary &#125;) &#123;  return (    &lt;div role=&quot;alert&quot;&gt;      &lt;p&gt;Something went wrong:&lt;/p&gt;      &lt;pre&gt;&#123;error.message&#125;&lt;/pre&gt;      &lt;button onClick=&#123;resetErrorBoundary&#125;&gt;Try again&lt;/button&gt;    &lt;/div&gt;  )&#125;function MyComponent() &#123;  // Some component logic that may throw JS errors&#125;function App() &#123;  return (    &lt;ErrorBoundary      FallbackComponent=&#123;MyFallbackComponent&#125;      onReset=&#123;() =&gt; &#123;        // reset the state of your app here      &#125;&#125;      resetKeys=&#123;['someKey']&#125;    &gt;      &lt;MyComponent /&gt;    &lt;/ErrorBoundary&gt;  )&#125;</code></pre><p>参考文档：<a href="https://blog.logrocket.com/react-error-handling-with-react-error-boundary/">使用 react-error-boundary 处理 React 错误 - LogRocket 博客</a></p><h3 id="设计模式：HOC-renderProps">设计模式：HOC + renderProps</h3><h4 id="render-props模式">render props模式</h4><p><code>render props</code> 是一种在React组件之间传递一个名为 <code>render</code> 的函数的模式，这个函数返回一个React元素。<code>render props</code> 模式允许组件通过其props接收一个函数，该函数负责决定组件如何渲染。这种方法提供了一种高度灵活的方式来构建可重用的组件。</p><h5 id="示例：">示例：</h5><p>假设我们有一个 <code>Button</code> 组件，我们想要根据不同的条件渲染不同的按钮样式或行为：</p><pre><code class="language-jsx">// ButtonWithRenderProp.jsimport React from 'react';const ButtonWithRenderProp = (&#123; render &#125;) =&gt; &#123;  const onClick = () =&gt; &#123;    console.log('Button clicked!');  &#125;;  return (    &lt;div&gt;      &#123;render(&#123; onClick &#125;)&#125;    &lt;/div&gt;  );&#125;;export default ButtonWithRenderProp;</code></pre><p>现在，我们可以这样使用这个组件：</p><pre><code class="language-jsx">// App.jsimport React from 'react';import ButtonWithRenderProp from './ButtonWithRenderProp';const App = () =&gt; &#123;  return (    &lt;ButtonWithRenderProp      render=&#123;(&#123; onClick &#125;) =&gt; (        &lt;button onClick=&#123;onClick&#125; style=&#123;&#123; background: 'blue', color: 'white' &#125;&#125;&gt;          Click me!        &lt;/button&gt;      )&#125;    /&gt;  );&#125;;export default App;</code></pre><p>在这个例子中，<code>ButtonWithRenderProp</code> 组件接收一个 <code>render</code> 函数作为prop，这个函数接收一个对象，其中包含一个 <code>onClick</code> 函数。然后，<code>render</code> 函数返回一个按钮元素，它使用传递进来的 <code>onClick</code> 函数。</p><h5 id="render-props-的特点："><code>render props</code> 的特点：</h5><ol><li class="lvl-3"><p><strong>动态渲染</strong>：组件可以动态决定如何渲染，基于传递给它的 <code>render</code> 函数。</p></li><li class="lvl-3"><p><strong>解耦组件</strong>：<code>render props</code> 允许你将组件的行为（通过 <code>render</code> 函数）与其结构（组件本身的JSX）解耦。</p></li><li class="lvl-3"><p><strong>可组合性</strong>：使用 <code>render props</code>，你可以轻松地组合多个组件，每个组件都可以贡献一部分渲染逻辑。</p></li></ol><h5 id="使用场景：">使用场景：</h5><ul class="lvl-0"><li class="lvl-2"><p><strong>动态组件</strong>：当你需要基于某些条件渲染不同的组件时。</p></li><li class="lvl-2"><p><strong>抽象UI</strong>：当你想要创建一个组件，它可以适应多种不同的渲染需求时。</p></li><li class="lvl-2"><p><strong>传递行为</strong>：当你想要将渲染逻辑作为props传递给子组件时。</p></li></ul><p>render props模式最重要的是它返回一个react元素，比如我将上面的render属性改名，依然有效。</p><pre><code class="language-js">import React from 'react';const SharedComponentWithGoofyName extends React.Component &#123;  render() &#123;    return (      &lt;div&gt;        &#123;this.props.wrapThisThingInADiv()&#125;      &lt;/div&gt;    );  &#125;&#125;const SayHelloWithGoofyName = () =&gt; (  &lt;SharedComponentWithGoofyName wrapThisThingInADiv=&#123;() =&gt; (    &lt;span&gt;hello!&lt;/span&gt;  )&#125; /&gt;);</code></pre><h4 id="HOC设计模式">HOC设计模式</h4><p>高阶组件（Higher Order Component，HOC）是React中用于重用组件逻辑的一种高级技术。它本身不是一个React组件，而是<strong>一个函数，这个函数接受一个组件作为参数，并返回一个新的组件</strong>。HOC让你能够重用组件之间的代码，如事件处理、订阅数据源、注入主题等，而不必在每个组件中重复这些代码。</p><blockquote><p>高阶组件在React生态链技术中经常用到，对读者较为熟悉的,比如Redux中的connect，React Router中的withRouter等。</p></blockquote><h5 id="HOC的主要特点：">HOC的主要特点：</h5><ol><li class="lvl-3"><p><strong>参数传递</strong>：HOC接收一个组件作为参数。</p></li><li class="lvl-3"><p><strong>返回组件</strong>：HOC返回一个新的组件。</p></li><li class="lvl-3"><p><strong>可重用性</strong>：通过HOC，你可以创建可重用的组件逻辑。</p></li><li class="lvl-3"><p><strong>无侵入性</strong>：HOC不会修改传入的组件，也不会使用继承，因此它们可以更容易地进行测试，并且可以保持干净。</p></li></ol><h5 id="使用场景：-2">使用场景：</h5><ul class="lvl-0"><li class="lvl-2"><p><strong>代码复用</strong>：当多个组件需要相同的功能时，可以使用HOC来避免重复代码。</p></li><li class="lvl-2"><p><strong>动态props注入</strong>：HOC可以添加新的props到组件，或者修改传递给子组件的props。</p></li><li class="lvl-2"><p><strong>渲染劫持</strong>：HOC可以在渲染组件之前或之后执行操作。</p></li><li class="lvl-2"><p><strong>关注点分离</strong>：将组件的业务逻辑和UI分离，使得组件更加专注于UI的展示。</p></li></ul><h5 id="代码示例">代码示例</h5><pre><code class="language-jsx">import React from 'react';// 假设的认证服务，用于模拟检查登录状态const AuthService = &#123;  isAuthenticated: () =&gt; &#123;    // 这里可以是异步操作，比如从localStorage获取token，然后验证token的有效性    // 模拟检查localStorage中是否有token    const token = localStorage.getItem('userToken');    return !!token; // 如果有token，返回true，表示用户已登录  &#125;&#125;;function withAuth(WrappedComponent) &#123;  return class extends React.Component &#123;    render() &#123;      const isLoggedIn = AuthService.isAuthenticated();      return &lt;WrappedComponent isLoggedIn=&#123;isLoggedIn&#125; &#123;...this.props&#125; /&gt;;    &#125;  &#125;;&#125;// 示例组件，使用HOC注入的isLoggedIn propclass SomeComponent extends React.Component &#123;  render() &#123;    const &#123; isLoggedIn &#125; = this.props;    if (isLoggedIn) &#123;      return &lt;div&gt;Welcome, you are logged in!&lt;/div&gt;;    &#125; else &#123;      return &lt;div&gt;Please log in to continue.&lt;/div&gt;;    &#125;  &#125;&#125;const AuthenticatedComponent = withAuth(SomeComponent);export default AuthenticatedComponent;</code></pre><h5 id="相同点：">相同点：</h5><ol><li class="lvl-3"><p>组件复用：HOC和Render Props都是用于实现组件复用的技术，使得我们可以在多个组件之间共享功能。</p></li><li class="lvl-3"><p>非侵入性：它们都是以非侵入性的方式添加功能到现有组件，不需要修改原始组件的代码。</p></li></ol><h5 id="不同点：">不同点：</h5><ol><li class="lvl-3"><p>抽象层级：HOC是一种在React中复用组件逻辑的高级技术。它实际上是一个函数，接受一个组件作为参数，并返回一个新的组件。这种方式可以使得组件逻辑与原始组件解耦，但可能会产生嵌套层级。<br>Render Props是通过props将一个函数传递给组件，这个函数允许组件在渲染时获取到特定的数据或行为。这样可以更加灵活地控制组件的行为。</p></li><li class="lvl-3"><p>组件结构：使用HOC时，我们在组件之外创建一个包裹组件，它会对原始组件进行包装，从而添加额外的功能。这意味着我们需要编写一个高阶函数来创建新的组件。使用Render Props时，我们在组件内部定义一个特定的prop，它是一个函数，用于传递所需的功能或数据。这种方式更加直接，不需要额外的高阶函数。</p></li><li class="lvl-3"><p>数据流：HOC可以通过props将数据传递给被包装的组件，但它不能直接访问被包装组件的state。在HOC中，数据流是从外部向内部。<br>Render Props允许组件在渲染过程中向内部传递数据，通常是通过props中的回调函数。在Render Props中，数据流是从内部向外部。</p></li></ol><h4 id="自定义-Hooks">自定义 Hooks</h4><p>任何相对独立、复用性强的逻辑,都可以 提取 为自定义 Hook，自定义 Hook 是一种复用 <a href="https://so.csdn.net/so/search?q=React&amp;spm=1001.2101.3001.7020">React</a> 的状态逻辑的函数。</p><p><strong>为什么要用自定义 Hook?</strong></p><ol><li class="lvl-3"><p><strong>提炼能复用的逻辑</strong><br>许多组件有相似的状态逻辑,使用自定义 Hook 可以很方便地提取出来复用。</p></li><li class="lvl-3"><p><strong>解决复杂组件的可读性问题</strong><br>使用自定义 Hook 将复杂组件拆分为更小的功能独立的函数,有助于提高代码的可读性。</p></li><li class="lvl-3"><p><strong>管理数据更新</strong><br>使用独立的 Hook 函数来管理数据请求、处理异步逻辑、数据缓存等,易于维护。</p></li><li class="lvl-3"><p><strong>分离状态逻辑</strong><br>自定义 Hook 让函数组件更纯粹,只负责 UI,状态逻辑则交给 Hook。</p></li><li class="lvl-3"><p><strong>调用其他 Hook</strong><br>自定义 Hook 本身还可以调用 useState、useEffect 等其他 React Hook。</p></li></ol><p>以下是总结的一些<strong>常用的hooks</strong>：</p><h5 id="1、useUpdateEffect">1、useUpdateEffect</h5><p><strong>useUpdateEffect作用</strong><br>useUpdateEffect 是一个自定义的 React Hook，用于在组件更新时执行副作用操作。它类似于 React 的 useEffect，但是会<strong>忽略组件的初始渲染阶段</strong>，只在<strong>组件更新时</strong>执行副作用操作。</p><ol><li class="lvl-3"><p><strong>避免初始渲染时执行副作用</strong>：有些副作用操作可能只需要在组件更新时执行，例如发送网络请求、更新特定状态等。使用 useUpdateEffect 可以确保这些副作用操作在初始渲染时被跳过，只在组件更新时执行。</p></li><li class="lvl-3"><p><strong>监听特定状态的变化</strong>：有时我们只关心特定状态的变化，并希望在状态发生变化时执行相应的操作。通过将状态值作为 useUpdateEffect 的依赖项，可以确保副作用操作只在这些状态发生变化时触发。</p></li><li class="lvl-3"><p><strong>更新外部资源或库</strong>：有些第三方库或外部资源可能需要在组件更新时进行更新或重新初始化。使用 useUpdateEffect 可以确保在组件更新时调用相应的函数或方法，以便正确地更新这些外部资源。</p></li></ol><p>以下是一个示例：</p><pre><code class="language-tsx">import &#123; useEffect, useState &#125; from 'react';function MyComponent() &#123;  const [count, setCount] = useState(0);  useEffect(() =&gt; &#123;    console.log('useEffect - Component has rendered');  &#125;);  useUpdateEffect(() =&gt; &#123;    console.log('useUpdateEffect - Component has updated');  &#125;);  return (    &lt;div&gt;      &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><p>在上述示例中，当点击 “Increment” 按钮时，<code>count</code> 的值会增加并触发组件的重新渲染。<code>useEffect</code> 会在每次渲染后执行，而 <code>useUpdateEffec</code>t 只会在组件更新时执行。</p><p>通过使用 <code>useUpdateEffect</code>，你可以在组件更新时执行一些特定的副作用操作，如请求数据、更新状态等，而不需要关心初始渲染阶段的操作。</p><p><strong>自定义useUpdateEffect</strong></p><p>要自定义一个类似于 <code>useUpdateEffect</code> 的自定义 Hook，你可以借助 React 的 <code>useEffect</code> 和 <code>useRef</code> Hooks 来实现。以下是一个示例代码：</p><pre><code class="language-tsx">import &#123; useEffect, useRef &#125; from 'react';function useUpdateEffect(effect, dependencies) &#123;  const isMounted = useRef(false);  useEffect(() =&gt; &#123;    if (isMounted.current) &#123;      effect();    &#125; else &#123;      isMounted.current = true;    &#125;  &#125;, dependencies);&#125;// 使用示例function MyComponent() &#123;  const [count, setCount] = useState(0);  useUpdateEffect(() =&gt; &#123;    console.log('Component has updated');  &#125;, [count]);  return (    &lt;div&gt;      &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><p>在上述示例中，我们创建了一个名为 <code>useUpdateEffect</code> 的自定义 Hook。它接受两个参数：<code>effect</code> 和 <code>dependencies</code>。在内部，我们使用了 <code>useRef</code> 来创建一个标记是否已经完成初始渲染的变量 <code>isMounted</code>。</p><p>在 useEffect 中，我们检查 isMounted 的值。如果 isMounted 的值为 true，则表示组件已经完成了初始渲染，此时执行传入的 effect 函数。否则，将 isMounted 的值设置为 true，表示组件已完成初始渲染。</p><p>在使用时，你可以像使用 useEffect 一样，传入 effect 函数和依赖项数组 dependencies，并且 effect 函数只会在组件更新时执行。</p><h5 id="2、useTitle">2、useTitle</h5><p>useTitle 是一个相对经典的自定义 React Hook ,用来控制浏览器标题:</p><p><strong>定义useTitle</strong></p><pre><code class="language-tsx">import &#123; useState, useEffect &#125; from 'react';function useTitle(initialTitle) &#123;  const [title, setTitle] = useState(initialTitle);   useEffect(() =&gt; &#123;    document.title = title;  &#125;, [title]);  return setTitle;&#125;</code></pre><p><strong>使用useTitle:</strong></p><pre><code class="language-tsx">function Page() &#123;  const setTitle = useTitle('Default Title');   return (    &lt;Button onClick=&#123;() =&gt; setTitle('New Title')&#125;&gt;      Click me    &lt;/Button&gt;  )&#125;</code></pre><p>点击按钮后,浏览器标题会变成&quot;New Title&quot;。它的工作原理是:</p><ul class="lvl-0"><li class="lvl-2"><p>保存标题的 state ,并记录修改 setTitle()</p></li><li class="lvl-2"><p>用 useEffect 监测 title 变化,设置 document.title</p><p>所以一旦我们调用 setTitle(‘New Title’) 改变 state ,useEffect 就会执行,设置新的浏览器标题。</p></li></ul><p>useTitle 的优点是:</p><ul class="lvl-0"><li class="lvl-2"><p>抽象出设置标题的逻辑,任何组件都可以共享</p></li><li class="lvl-2"><p>让组件更纯粹,只需要调用 setTitle() 接口即可</p></li></ul><p>我们甚至可以抽象为更通用的 Hook:</p><pre><code class="language-tsx">function useDocumentTitle(title) &#123;  useEffect(() =&gt; &#123;    document.title = title;  &#125;, [title]);&#125;function Page() &#123;  useDocumentTitle('Default Title');  // ...&#125;</code></pre><h5 id="3、useForceUpdate">3、useForceUpdate</h5><p><strong>定义useForceUpdate</strong></p><pre><code class="language-tsx">import &#123; useState &#125; from 'react';function useForceUpdate() &#123;  const [, setValue] = useState(0);     return () =&gt; &#123;    setValue(value =&gt; !value);       //这里的value =&gt; !value是一个函数，它接收当前的state（在这个例子中是0或1）作为参数value，然后返回其布尔反转值。  &#125;;&#125;</code></pre><p><strong>useForceUpdate的使用</strong></p><pre><code class="language-tsx">const forceUpdate = useForceUpdate();// 模拟更新组件forceUpdate();</code></pre><p>这个 Hook 返回了一个更新函数。在调用这个函数时,使用useState强制组件重新渲染。这是基于以下原理实现的:</p><ul class="lvl-0"><li class="lvl-2"><p>useState()会触发组件重新渲染</p></li><li class="lvl-2"><p>state变化后,组件函数会重新执行</p></li></ul><p>函数式组件只有 state 或 props 变化时才会更新。使用此 Hook 我们可以主动触发组件更新。比如在使用过时数据时:</p><pre><code class="language-tsx">// 过时数据 const &#123; data &#125; = useSomeHook();// 更新组件const forceUpdate = useForceUpdate();setInterval(() =&gt; &#123;  forceUpdate();&#125;, 5000);</code></pre><p>每5秒强制组件一次,保证拿到最新数据。</p><h5 id="4、useDebounce">4、useDebounce</h5><p><strong>定义</strong></p><pre><code class="language-tsx">import &#123; useState, useEffect &#125; from 'react';const useDebounce = (value, delay) =&gt; &#123;  const [debouncedValue, setDebouncedValue] = useState(value);  useEffect(() =&gt; &#123;    let handler = setTimeout(() =&gt; &#123;      setDebouncedValue(value);    &#125;, delay);    return () =&gt; &#123;      clearTimeout(handler);    &#125;;  &#125;, [value, delay]);  return debouncedValue;&#125;;export default useDebounce;</code></pre><p><strong>使用</strong></p><pre><code class="language-tsx">const inputValue = useDebounced(searchTerm, 500);</code></pre><p>这里 每当<code>searchTerm</code>变化时,会设置一个 500ms 的定时器。只有500ms内没有再改变<code>searchTerm</code>,才会更新<code>debouncedValue</code>。</p><p><strong>防抖</strong>（Debouncing）：确保函数在指定的时间间隔内最多只执行一次。如果在时间间隔内多次触发，只有最后一次触发会被执行。</p><p>防抖是一种限制函数被频繁调用的模式，确保函数在指定的时间间隔 <code>delay</code> 后执行，如果在这段时间内再次触发，则重新开始计时。这在处理诸如输入框内容变化、窗口大小调整等频繁触发的事件时非常有用。</p><p><strong>防抖原理</strong></p><ul class="lvl-0"><li class="lvl-2"><p>当<code>value</code>变化时，<code>useEffect</code>钩子会重新运行，并设置一个新的定时器。</p></li><li class="lvl-2"><p>如果在定时器触发之前<code>value</code>再次变化，之前的定时器会被清理，并且设置一个新的定时器。</p></li><li class="lvl-2"><p>只有当在<code>delay</code>指定的时间间隔内没有新的<code>value</code>变化时，定时器才会触发，执行<code>setDebouncedValue(value)</code>，更新<code>debouncedValue</code>。</p></li><li class="lvl-2"><p>这确保了<code>setDebouncedValue</code>只在最后一次<code>value</code>变化后的<code>delay</code>时间间隔结束后调用，实现了防抖效果。</p></li></ul><h5 id="5、useThrottle">5、useThrottle</h5><p><strong>定义</strong></p><pre><code class="language-tsx">import &#123; useState, useEffect &#125; from 'react';const useThrottle = (value, limit) =&gt; &#123;  const [throttledValue, setThrottledValue] = useState(value);  const latestValue = useRef(value); // 使用 useRef 来保存最新的值  useEffect(() =&gt; &#123;    let handler = setTimeout(() =&gt; &#123;      if (latestValue.current !== undefined) &#123;        setThrottledValue(latestValue.current);      &#125;    &#125;, limit);    latestValue.current = value;    return () =&gt; &#123;      clearTimeout(handler);    &#125;;  &#125;, [value, limit]); // 依赖项包含 value 和 limit  return throttledValue;&#125;;</code></pre><p>我们使用 <code>useRef</code> 来保存最新的 <code>value</code>，并在 <code>useEffect</code> 中更新它。这样，无论 <code>value</code> 变化多快，我们总是可以在定时器触发时获取到最新的值。</p><p><strong>使用</strong></p><pre><code class="language-tsx">const throttledValue = useThrottle(inputValue, 1000);</code></pre><p>这里 每次<code>inputValue</code>变化时,会开始一个计时器。1s后才会更新<code>throttledValue</code>,实现了节流功能。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>节流</strong>（Throttling）：确保函数在指定的时间间隔内至少执行一次。无论触发多少次，函数都会在时间间隔内定期执行。</p></li></ul><p><strong>主要区别</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>触发时机</strong>：防抖是最后一次触发后等待，节流是在每次触发后等待。</p></li><li class="lvl-2"><p><strong>适用场景</strong>：防抖适用于输入验证等操作，节流适用于滚动事件、窗口调整等频繁触发的操作。</p></li><li class="lvl-2"><p><strong>副作用执行</strong>：防抖可能在快速连续触发后完全不执行副作用，节流保证在每个间隔内至少执行一次。</p></li></ul><h5 id="6、useInterval">6、useInterval</h5><p><strong>定义</strong></p><pre><code class="language-tsx">import &#123; useRef, useEffect &#125; from 'react';const useInterval = (callback, delay) =&gt; &#123;  const savedCallback = useRef();  useEffect(() =&gt; &#123;    savedCallback.current = callback;  &#125;, [callback]);  useEffect(() =&gt; &#123;    function tick() &#123;      savedCallback.current();    &#125;    if (delay !== null) &#123;      let id = setInterval(tick, delay);      return () =&gt; clearInterval(id);    &#125;  &#125;, [delay]);&#125;;export default useInterval;</code></pre><p><strong>使用</strong></p><pre><code class="language-tsx">useInterval(() =&gt; &#123;  // ...&#125;, 1000); </code></pre><p>这里每1000ms就会调用一次回调函数,实现了定时执行指定函数的功能。</p><ul class="lvl-0"><li class="lvl-2"><p>基本流程</p></li><li class="lvl-2"><p>合成事件</p></li><li class="lvl-2"><p>fiber</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器输入URL后发生了什么</title>
      <link href="/2024/03/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2024/03/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1>浏览器输入URL后发生了什么</h1><p><strong>大致流程</strong></p><ol><li class="lvl-3"><p>URL解析</p></li><li class="lvl-3"><p>DNS查询</p></li><li class="lvl-3"><p>TCP连接</p></li><li class="lvl-3"><p>处理请求</p></li><li class="lvl-3"><p>接受响应</p></li><li class="lvl-3"><p>渲染页面</p></li></ol><h2 id="一、URL解析">一、URL解析</h2><p><strong>地址解析：</strong></p><p>用户输入url，处理输入信息：</p><p>如果为非url结构的字符串，交给浏览器<strong>默认引擎</strong>去搜索该字符串；</p><p>若为url结构的字符串，浏览器主进程会交给 <strong>网络进程</strong> ,开始干活。</p><p><strong>HSTS</strong></p><p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<a href="https://link.zhihu.com/?target=https%3A//www.barretlee.com/blog/2015/10/22/hsts-intro/">你所不知道的 HSTS</a>。</p><p><strong>其他操作</strong></p><p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><p><strong>检查缓存</strong></p><p><img src="https://pic1.zhimg.com/80/v2-0489444034d569b37867e2e527a7d5d4_1440w.webp" alt="img"></p><p>网络进程会先看看是否存在本地缓存，如果有就直接返回资源给浏览器进程，无则下一步 DNS-&gt; IP -&gt; TCP</p><h2 id="二、DNS查询">二、DNS查询</h2><p>封装好HTTP请求报文之后，就需要获取目标服务器的ip地址（ip包里面有ip地址），虽然解析得到了域名，按理浏览器应该已经知道了目标服务器是谁了。但是实际上，域名并不是目标服务器真正意义上的地址，互联网上每一台计算机都被全世界唯一IP地址标识着，但是IP地址并不方便记忆，所以才设计出了域名。但是虽然域名容易被用户所接受和使用，但是计算机只能识别纯数字构成的IP地址，不能直接读取域名。所以如果只是知道域名也不知道这个请求会被发送到哪里去。那么就需要解析域名获取目标服务器的IP地址。</p><p>//DNS域名解析IP地址的过程，其实就是不断“询问”的过程，如果问的这个人不知道，就会告诉你“可能知道对应的IP地址”的人，让你去问他。</p><p>DNS域名解析IP地址的过程：</p><p><img src="https://s2.loli.net/2024/03/17/UHyaqG9eZCEikKv.png" alt="5b0d71fa241ebedfb313c20828fbf410.png"></p><p>1.客户端首先查看浏览器缓存，看有没有该域名对应的IP地址</p><p>2.如果没有的话，查看本地host文件，看有没有该域名对应的IP地址</p><p>3.如果没有的话，客户端向本地域名服务器进行递归查询，查询该域名对应的IP地址</p><p>4.如果还是没有的话，本地域名服务器向根域名服务器进行迭代查询，根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器</p><p>5.本地域名服务器再向顶级域名服务器查询，顶级域名服务器要么给出所要查询的IP地址，要么告诉本地服务器下一步应该向哪一个权限域名服务器进行查询</p><p>6.本地域名服务器向权限域名服务器进行查询，然后得到了所要解析的IP地址</p><p>7.本地域名服务器将该域名和对应的IP地址写入自身缓存，然后将解析的IP地址返回给客户端</p><h2 id="三、TCP连接（三次握手）">三、TCP连接（三次握手）</h2><p>有了IP地址，我们就能找到目标服务器，开始连接咯。</p><p>HTTP 通讯的基础是 TCP 连接，TCP 连接需要 3 次握手，3 次握手就是为了验证客户端的发送能力和接收能力，以及服务器端的发生能力和接收能力，就像打电话一样，通常的通话是这样开头的：我：喂，能听到吗？对方：能听到，你能听到吗？（证明了对方的接收能力和我的发送能力）我：我也能听到，咱们聊正事吧。（证明了对方的发送能力和我的接收能力）经过以上 3 次握手就可以证明客户端的发送能力和接收能力，以及服务器端的发生能力和接收能力，这样就可以正式开始通讯了。</p><p>三次握手过程的示意图如下：</p><p><img src="https://pic1.zhimg.com/80/v2-8ce8c897b4d5e7397b25eb4d4b31d7fc_1440w.webp" alt="img"></p><ul class="lvl-0"><li class="lvl-2"><p><strong>第一次握手</strong>：客户端将TCP报文<strong>标志位SYN置为1</strong>，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入<code>SYN_SENT</code>状态，等待服务器端确认。</p></li><li class="lvl-2"><p><strong>第二次握手</strong>：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文<strong>标志位SYN和ACK都置为1</strong>，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入<code>SYN_RCVD</code>状态。</p></li><li class="lvl-2"><p><strong>第三次握手</strong>：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p></li></ul><p>TCP链接建立后，就可以发送HTTP请求啦。</p><h2 id="四、服务器处理请求">四、服务器处理请求</h2><ol><li class="lvl-3"><p>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤HTTP Host头部判断请求的服务程序</p></li><li class="lvl-3"><p>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>，如果验证缓存新鲜，返回304等对应状态码</p></li><li class="lvl-3"><p>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p></li><li class="lvl-3"><p>服务器将响应报⽂通过TCP连接发送回浏览器</p></li></ol><h2 id="五、接受响应">五、接受响应</h2><ol><li class="lvl-3"><p>浏览器接收HTTP响应，然后根据情况选择<strong>关闭TCP连接或者保留重⽤</strong>，关闭TCP连接的四次握⼿如下：</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>主动⽅发送Fin=1， Ack=Z， Seq= X报⽂</p></li><li class="lvl-2"><p>被动⽅发送ACK=X+1， Seq=Z报⽂</p></li><li class="lvl-2"><p>被动⽅发送Fin=1， ACK=X， Seq=Y报⽂</p></li><li class="lvl-2"><p>主动⽅发送ACK=Y， Seq=X报⽂</p></li></ul><ol start="2"><li class="lvl-3"><p>浏览器检查响应状态码：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</p></li><li class="lvl-3"><p>如果资源可缓存，<strong>进行缓存</strong></p></li><li class="lvl-3"><p>对响应<strong>进行解码</strong>（例如gzip压缩）</p></li><li class="lvl-3"><p>根据资源类型决定如何处理（假设资源为HTML⽂档）</p></li></ol><h2 id="六、渲染页面">六、渲染页面</h2><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p><strong>基本流程</strong></p><p><img src="https://pic3.zhimg.com/80/v2-d2ea43fca9c994d20b2d83b94358111e_1440w.webp" alt="img"></p><h3 id="1-HTML-解析"><strong>1.HTML 解析</strong></h3><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><p><strong>1. 解码（encoding）</strong></p><p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。</p><p><strong>2. 预解析（pre-parsing）</strong></p><p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如<code>img</code>标签的<code>src</code>属性，并将这个请求加到请求队列中。</p><p><strong>3. 符号化（Tokenization）</strong></p><p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到<code>&lt;</code>，<code>&gt;</code>状态都会产生变化。</p><p><strong>4. 构建树（tree construction）</strong></p><blockquote><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p></blockquote><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p><pre><code class="language-html">&lt;html&gt;&lt;head&gt;    &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;h1&gt;Web page parsing&lt;/h1&gt;        &lt;p&gt;This is an example Web page.&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://pic4.zhimg.com/80/v2-2ac7c987b3f88c96884ac551cfe7c317_1440w.webp" alt="img"></p><p><strong>浏览器容错进制</strong></p><p>你从来没有在浏览器看过类似&quot;语法无效&quot;的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p><strong>事件</strong></p><p>当整个解析的过程完成以后，浏览器会通过<code>DOMContentLoaded</code>事件来通知<code>DOM</code>解析完成。</p><h3 id="2-CSS-解析"><strong>2. CSS 解析</strong></h3><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据<a href="https://link.zhihu.com/?target=https%3A//drafts.csswg.org/css-syntax-3/">语法规范</a>解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong></p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p &#123; font-size :14px &#125;</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。</p><p>所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p><h3 id="3-渲染树"><strong>3. 渲染树</strong></h3><p>其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p></blockquote><p><strong>计算</strong></p><p>通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p><p><strong>级联</strong></p><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p><ol><li class="lvl-3"><p>标签名、class、id</p></li><li class="lvl-3"><p>是否内联样式</p></li><li class="lvl-3"><p><code>!important</code></p></li></ol><p>然后得出一个权重值，取最高的那个。</p><p>层叠优先级是:</p><p><strong>浏览器缺省 &lt; 外部样式表 &lt; 内部样式表 &lt; 内联样式</strong></p><p>其中样式表又有:</p><p><strong>类选择器 &lt; 类派生选择器 &lt; ID选择器 &lt; ID派生选择器</strong></p><p><strong>渲染阻塞</strong></p><p>当遇到一个<code>script</code>标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所以我们知道：</p><ul class="lvl-0"><li class="lvl-2"><p>CSS 会阻塞 JS 执行</p></li><li class="lvl-2"><p>JS 会阻塞后面的 DOM 解析</p></li></ul><p>为了避免这种情况，应该以下原则：</p><ul class="lvl-0"><li class="lvl-2"><p>CSS 资源排在 JavaScript 资源前面</p></li><li class="lvl-2"><p>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</p></li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://link.zhihu.com/?target=https%3A//github.com/xiaoyu2er/blog/issues/8">这篇文章</a></p><h3 id="4-布局与绘制"><strong>4. 布局与绘制</strong></h3><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><h3 id="5-合并渲染层"><strong>5. 合并渲染层</strong></h3><p>把以上绘制的所有图片合并，最终输出一张图片。</p><h3 id="6-回流与重绘"><strong>6. 回流与重绘</strong></h3><p><strong>回流(reflow)</strong></p><p>当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从<code>html</code>标签开始递归往下，重新计算位置和大小。</p><p>reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘(repaint)</strong></p><p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</p><p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p><p>比如：</p><ul class="lvl-0"><li class="lvl-2"><p><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</p></li></ul><h3 id="7-JavaScript-编译执行"><strong>7. JavaScript 编译执行</strong></h3><p><strong>大致流程</strong></p><p><img src="https://pic4.zhimg.com/80/v2-6ce3a70730963ec458189e78c5a2f217_1440w.webp" alt="img"></p><p>可以分为三个阶段：</p><h3 id="1-词法分析"><strong>1. 词法分析</strong></h3><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。</p><p>几个步骤：</p><ul class="lvl-0"><li class="lvl-2"><p>分词，例如将<code>var a = 2</code>，，分成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>这样的词法单元。</p></li><li class="lvl-2"><p>解析，将词法单元转换成抽象语法树（AST）。</p></li><li class="lvl-2"><p>代码生成，将抽象语法树转换成机器指令。</p></li></ul><h3 id="2-预编译"><strong>2. 预编译</strong></h3><p>JS 有三种运行环境：</p><ul class="lvl-0"><li class="lvl-2"><p>全局环境</p></li><li class="lvl-2"><p>函数环境</p></li><li class="lvl-2"><p>eval</p></li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p><strong>创建执行上下文</strong></p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul class="lvl-0"><li class="lvl-2"><p>创建变量对象</p><ul class="lvl-2"><li class="lvl-4">参数、函数、变量</li></ul></li><li class="lvl-2"><p>建立作用域链</p><ul class="lvl-2"><li class="lvl-4">确认当前执行环境是否能访问变量</li></ul></li><li class="lvl-2"><p>确定 This 指向</p></li></ul><h3 id="3-执行"><strong>3. 执行</strong></h3><p><strong>JS 线程</strong></p><p><img src="https://pic1.zhimg.com/80/v2-1cf9f632051663cc8c8415c29dadbcc0_1440w.webp" alt="img"></p><p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</p></li><li class="lvl-2"><p>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</p></li><li class="lvl-2"><p>定时器触发线程：主要控制<code>setInterval</code>和<code>setTimeout</code>，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</p></li><li class="lvl-2"><p>HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</p></li></ul><p><strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p><p><strong>浏览器事件循环</strong></p><p>**同步任务、异步任务：**JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。</p><p><strong>宏任务(macro-task)、微任务(micro-task):</strong><br>除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。<br><strong>macro-task</strong>包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。<br><strong>micro-task</strong>包括：process.nextTick, Promises, Object.observe, MutationObserver。</p><p>第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。</p><pre><code class="language-js">console.log(1);setTimeout(function() &#123;    console.log(2);&#125;)var promise = new Promise(function(resolve, reject) &#123;    console.log(3);    resolve();&#125;)promise.then(function() &#123;    console.log(4);&#125;)console.log(5);//输出1，3，5，4，2</code></pre><ul class="lvl-0"><li class="lvl-2"><p>上面的示例中，第一次事件循环，整段代码作为宏任务进入主线程执行。</p></li><li class="lvl-2"><p>遇到了 setTimeout ，就会等到过了指定的时间后将回调函数放入到宏任务的任务队列中。</p></li><li class="lvl-2"><p>遇到 Promise，将 then 函数放入到微任务的任务队列中。</p></li><li class="lvl-2"><p>整个事件循环完成之后，会去检测微任务的任务队列中是否存在任务，存在就执行。</p></li><li class="lvl-2"><p>第一次的循环结果打印为: 1,3,5,4。</p></li><li class="lvl-2"><p>接着再到宏任务的任务队列中按顺序取出一个宏任务到栈中让主线程执行，那么在这次循环中的宏任务就是 setTimeout 注册的回调函数，执行完这个回调函数，发现在这次循环中并不存在微任务，就准备进行下一次事件循环。</p></li><li class="lvl-2"><p>检测到宏任务队列中已经没有了要执行的任务，那么就结束事件循环。</p></li><li class="lvl-2"><p>最终的结果就是 1,3,5,4,2。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>echarts</title>
      <link href="/2024/03/03/2024-3-3-echarts/"/>
      <url>/2024/03/03/2024-3-3-echarts/</url>
      
        <content type="html"><![CDATA[<h1>echarts入门</h1><h2 id="一-echarts的介绍">一.echarts的介绍</h2><p>1.echarts是一款基于JavaScript的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。ECharts最初由百度团队开源，并于2018年初捐赠给Apache基金会，成为ASF孵化级项目。<br>2.学习一项技术的关键，还是需要多读官方文档，官网链接Apache ECharts,与之类似的图表库还有D3，HeightCharts。<br>3.echarts的下载（1）从 npm 获取</p><pre><code>npm install echarts --save</code></pre><p>（2）从 CDN 获取（3）从 GitHub 获取</p><h2 id="二-echarts语法">二.echarts语法</h2><p>一.echarts常见术语</p><table><thead><tr><th>英文</th><th>汉语</th></tr></thead><tbody><tr><td>title</td><td>标题</td></tr><tr><td>legend</td><td>图例</td></tr><tr><td>tooltip</td><td>提示</td></tr><tr><td>xAxis</td><td>x轴线</td></tr><tr><td>yAxis</td><td>y轴线</td></tr><tr><td>series</td><td>系列</td></tr><tr><td>data</td><td>数据</td></tr></tbody></table><p>二.图表常见类型<br>bar 柱状图<br>line折线图<br>(1)曲线图加上<code>smooth:true;</code>就会变成曲线图<br>(2)面积图加上<code>areaStyle:&#123;fill:“#f70”&#125;</code> 会变成面积图<br>pie 饼形图（1）加上<code>radius:[80,50]</code> 会变成环形图</p><h2 id="三-echarts-中的样式简介">三.echarts 中的样式简介</h2><ol><li class="lvl-3"><p>颜色主题（1）主题可以通过切换深色模式，直接看到采用主题的效果通过light 、dark切换定制主题，具体可以参考官网，需要导入下载的js文件</p></li></ol><pre><code class="language-javascript">// HTML 引入 vintage.js 文件后（假设主题名称是 &quot;vintage&quot;）var chart = echarts.init(dom, 'vintage');// ...</code></pre><p>（2）color调色盘在 option 中设置。可以设置全局的调色盘，也可以设置系列自己专属的调色盘。全局调色盘option.color</p><pre><code class="language-javascript">option.color：color: [&quot;pink&quot;, &quot;#ff0&quot;, &quot;#f0f&quot;, &quot;#0ff&quot;]</code></pre><p>局部调色盘series.item.color</p><pre><code class="language-javascript">series: [    &#123;      type: 'bar',      // 此系列自己的调色盘。      color: [        '#dd6b66',        '#759aa0',        '#e69d87',        '#8dc1a9',        '#ea7e53',        '#eedd78',        '#73a373',        '#73b9bc',        '#7289ab',        '#91ca8c',        '#f49f42'      ]         &#125;,</code></pre><p>（3）itemStyle项的颜色</p><ul class="lvl-0"><li class="lvl-2"><p>itemStyle:{color:“#00f” }</p></li><li class="lvl-2"><p>高亮的样式emphasis</p><pre><code class="language-javascript">itemStyle:&#123;normal:&#123;color:&quot;#93da6c&quot;&#125;,emphasis:&#123;color:&quot;#bcff57&quot;&#125;&#125;</code></pre><ol start="2"><li class="lvl-5"><p>特殊样式渐变色（1）定义渐变</p><pre><code class="language-javascript">// 定义渐变var linear = &#123;  type: 'linear',  x: 0,  y: 0,  x2: 0,  y2:1,  colorStops: [&#123;  offset: 0, color: '#02bcff' // 0% 处的颜色  &#125;, &#123;  offset: 1, color: '#5555ff' // 100% 处的颜色  &#125;],  global: false // 缺省为 false&#125;</code></pre><p>（2）使用渐变</p><pre><code class="language-javascript">itemStyle:&#123;color:linear,borderRadius:[30,30,0,0]&#125;</code></pre></li></ol></li></ul><h2 id="四-动态显示局部">四.动态显示局部</h2><ol><li class="lvl-3"><p>定义option</p></li><li class="lvl-3"><p>修改option值</p></li><li class="lvl-3"><p>echart.setOption(option);更新数据和视图</p></li></ol><h2 id="五-缓动动画">五.缓动动画</h2><p>动画延迟 animationDelay</p><p>动画时长 animationDuration</p><p>动画缓动函数 animationEasing</p><pre><code class="language-javascript">animationDelay: function(idx) &#123;// 越往后的数据延迟越大return idx * 200;&#125;,animationDuration: function(idx) &#123;// 每小格动画的时候return idx * 200;&#125;,// 弹性的方式出现动画animationEasing: &quot;bounceInOut&quot;&#125;</code></pre><h2 id="三-echarts应用">三.echarts应用</h2><pre><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;!-- 01 导入js --&gt;&lt;script src=&quot;js/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 03 设置容器的样式 --&gt;&lt;style&gt;#container&#123;width: 800px;height: 600px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 02 创建个容器 --&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;//04 实例化echarts// 4.1 创建一个实例var echart = echarts.init(document.getElementById(&quot;container&quot;))// 4.2 定义配置项var option = &#123;// 图表的标题title:&#123;text:&quot;我的第一个图表&quot;&#125;,// 图表的提示tooltip:&#123;&#125;,// 图例legend:&#123;data:[&quot;睡眠时长&quot;]&#125;,// x轴线xAxis:&#123;data:[&quot;周一&quot;,&quot;周二&quot;,&quot;周三&quot;,&quot;周四&quot;,&quot;周五&quot;,&quot;周六&quot;,&quot;周日&quot;]&#125;,// y轴线yAxis:&#123;&#125;,// 设置数据series:[&#123;// 数据名称name:&quot;睡眠时长&quot;,// 类型为柱状图type:&quot;bar&quot;,// 数据datadata:[8,10,4,5,9,4,8]&#125;]&#125;// 4.3 更新配置echart.setOption(option);// chart图表，set设置 Option选项  data数据 type类型 bar条（柱状条），series系列（数据） Axis轴线 xAxis水平轴线 // legend传奇（图例） tooltip 提示 init初始化 document文档 &lt;/script&gt;&lt;/html&gt;</code></pre><h1>在taro+react构建的微信小程序里引入echarts</h1><h2 id="1-引入-组件-ec-canvas">1. 引入 组件 ec-canvas</h2><p>下载Echarts官方的小程序插件echarts-for-weixin <a href="https://github.com/ecomfe/echarts-for-weixin">传送门</a></p><p><img src="https://img-blog.csdnimg.cn/c8b4e2c4f67c43dd88457ada54a57fc5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVl9BWUFfVg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li class="lvl-3"><p>将项目中的ec-<a href="https://so.csdn.net/so/search?q=canvas&amp;spm=1001.2101.3001.7020">canvas</a>文件夹复制保存</p></li><li class="lvl-3"><p>去Echarts官网定制图表(不建议全部下载，文件太大，小程序体积大需要分包) <a href="https://echarts.apache.org/zh/builder.html">传送门</a></p></li><li class="lvl-3"><p>压缩echarts.js文件(压缩方法可以自行找线上压缩网站或自行压缩，方法附后文）</p></li><li class="lvl-3"><p>替换ec-canvas文件中的echarts.js文件</p></li></ol><p><img src="https://img-blog.csdnimg.cn/375e575d3d6542d0915643b9ac1e9cda.png" alt="在这里插入图片描述"></p><h2 id="2-在页面配置文件中配置-usingComponents属性">2.在页面配置文件中配置  usingComponents属性</h2><pre><code class="language-javascript">export default &#123;  usingComponents: &#123;    // 定义需要引入的第三方组件    // 1. key 值指定第三方组件名字，以小写开头    // 2. value 值指定第三方组件 js 文件的相对路径    'ec-canvas': '../../components/ec-canvas/ec-canvas'  &#125;&#125;</code></pre><h2 id="3-小程序封装图表组件">3.小程序封装图表组件</h2><pre><code class="language-js"> class Chart extends Component &#123;    constructor(props) &#123;      super(props)      this.state = &#123;        ec: &#123;          onInit: function (canvas, width, height) &#123;            const chart = echarts.init(canvas, null, &#123;              width: width,              height: height            &#125;);            canvas.setChart(chart);            const option = &#123;              title: &#123;                text: 'Distribution of Electricity',                subtext: 'Fake Data'              &#125;,              tooltip: &#123;                trigger: 'axis',                axisPointer: &#123;                  type: 'cross'                &#125;              &#125;,              toolbox: &#123;                show: true,                feature: &#123;                  saveAsImage: &#123;&#125;                &#125;              &#125;,              xAxis: &#123;                type: 'category',                boundaryGap: false,                // prettier-ignore                data: ['00:00', '01:15', '02:30', '03:45', '05:00', '06:15', '07:30', '08:45', '10:00', '11:15', '12:30', '13:45', '15:00', '16:15', '17:30', '18:45', '20:00', '21:15', '22:30', '23:45']              &#125;,              yAxis: &#123;                type: 'value',                axisLabel: &#123;                  formatter: '&#123;value&#125; W'                &#125;,                axisPointer: &#123;                  snap: true                &#125;              &#125;,              visualMap: &#123;                show: false,                dimension: 0,                pieces: [                  &#123;                    lte: 6,                    color: 'green'                  &#125;,                  &#123;                    gt: 6,                    lte: 8,                    color: 'red'                  &#125;,                  &#123;                    gt: 8,                    lte: 14,                    color: 'green'                  &#125;,                  &#123;                    gt: 14,                    lte: 17,                    color: 'red'                  &#125;,                  &#123;                    gt: 17,                    color: 'green'                  &#125;                ]              &#125;,              series: [                &#123;                  name: 'Electricity',                  type: 'line',                  smooth: true,                  // prettier-ignore                  data: [300, 280, 250, 260, 270, 300, 550, 500, 400, 390, 380, 390, 400, 500, 600, 750, 800, 700, 600, 400],                  markArea: &#123;                    itemStyle: &#123;                      color: 'rgba(255, 173, 177, 0.4)'                    &#125;,                    data: [                      [                        &#123;                          name: 'Morning Peak',                          xAxis: '07:30'                        &#125;,                        &#123;                          xAxis: '10:00'                        &#125;                      ],                      [                        &#123;                          name: 'Evening Peak',                          xAxis: '17:30'                        &#125;,                        &#123;                          xAxis: '21:15'                        &#125;                      ]                    ]                  &#125;                &#125;              ]            &#125;;            chart.setOption(option)            return chart;          &#125;        &#125;      &#125;    &#125;    render() &#123;      return (          &lt;View className='canvas-container'&gt;            &lt;ec-canvas id='mychart-dom-bar' canvas-id='mychart-bar' ec=&#123;this.state.ec&#125;&gt;&lt;/ec-canvas&gt;          &lt;/View&gt;      )    &#125;  &#125;</code></pre><p>在需要使用图表的部分插入<code>&lt;Chart&gt;&lt;/Chart&gt;</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> echarts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React路由</title>
      <link href="/2024/01/26/React%E8%B7%AF%E7%94%B1/"/>
      <url>/2024/01/26/React%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="React路由介绍">React路由介绍</h2><p>现代的前端应用大多都是 <a href="https://so.csdn.net/so/search?q=SPA&amp;spm=1001.2101.3001.7020">SPA</a>（单页应用程序）single page application，也就是只有一个 HTML 页面的应用程序。因为它的用户体验更好、对服务器的压力更小，所以更受欢迎。</p><p>为了有效的使用单个页面来管理原来多页面的功能，前端路由应运而生。</p><blockquote><p>前端路由的功能：让用户<strong>从一个视图（页面）导航到另一个视图（页面）</strong></p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>前端路由是一套映射规则，在React中，是 URL路径 与 组件 的对应关系 。一个路由就是一对映射关系–&gt;key：value</p></li><li class="lvl-2"><p>使用React路由简单来说，就是配置 路径和组件（配对）</p></li></ul><p><strong>前后端路由介绍</strong></p><ol><li class="lvl-3"><p>后端路由：<br>1)理解： value是function, 用来处理客户端提交的请求。<br>2)注册路由： router.get(path, function(req, res))<br>3)工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</p></li><li class="lvl-3"><p>前端路由：<br>1)浏览器端路由，value是component，用于展示页面内容。<br>2)注册路由: <Route path="/test" component={Test}><br>3)工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</p></li></ol><p><strong>路由的本质:</strong> 一个路径 path 对应唯一的一个组件 component 当我们访问一个 path 自动把 path 对应的组件进行渲染。</p><h2 id="React-路由的基本使用">React 路由的基本使用</h2><p><strong>1. 安装</strong></p><p>首先你要有一个React项目：（这是 React 脚手架初始化项目）</p><pre><code>npx create-react-app my-app</code></pre><p>注：<strong>React 路由使用前需要*<em>先安装 react-router-dom 的包*</em></strong>，React <a href="https://so.csdn.net/so/search?q=%E8%84%9A%E6%89%8B%E6%9E%B6&amp;spm=1001.2101.3001.7020">脚手架</a>初始化项目时不会自动安装这个包，需要我们手动再安装</p><p><strong>安装包</strong>：<code>yarn add react-router-dom</code> 或 <code>npm i react-router-dom@6</code></p><p><strong>2.React路由demo</strong></p><p>代码示例：</p><pre><code class="language-javascript">import &#123; BrowserRouter, Routes, Route, Link &#125; from 'react-router-dom' function Home () &#123;  return (    &lt;p&gt;这是首页的内容&lt;/p&gt;  )&#125;function About () &#123;  return (    &lt;p&gt;这是关于的内容&lt;/p&gt;  )&#125;function App () &#123;  return (    // 声明当前要用一个非hash模式的路由    &lt;BrowserRouter&gt;      &lt;div className=&quot;App&quot;&gt;        &#123;/* 指定跳转的组件，to 用来配置路由地址 */&#125;        &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;br /&gt;        &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;        &#123;/* 路由出口：路由对应的组件会在这里进行渲染 */&#125;        &lt;Routes&gt;          &#123;/* 指定路由路径和组件的对应关系：path 代表路径，element 代表对应的组件，它们成对出现 */&#125;          &lt;Route path='/' element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;          &lt;Route path='/about' element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;        &lt;/Routes&gt;      &lt;/div&gt;    &lt;/BrowserRouter&gt;  )&#125; export default App</code></pre><p><strong>3.总结</strong></p><p>两种常用的路由模式：BrowserRouter和HashRouter</p><table><thead><tr><th>核心组件</th><th>功能</th></tr></thead><tbody><tr><td>BrowserRouter</td><td>声明当前要用一个非hash的模式的路由包裹整个应用。一个React应用只需使用一次。使用 H5 的 history.pushState API 实现（<a href="http://localhost:3000/first%EF%BC%89%EF%BC%88**%E6%8E%A8%E8%8D%90**%EF%BC%89">http://localhost:3000/first）（**推荐**）</a></td></tr><tr><td>HashRouter</td><td>hash模式的路由。一个有#（HashRouter），一个不带#（BrowserRouter）                                                          使用 URL 的哈希值实现（<a href="http://localhost:3000/#/first%EF%BC%89">http://localhost:3000/#/first）</a></td></tr><tr><td>Link</td><td>指定导航链接，完成路由跳转。to属性指定路由地址，最终被渲染为a标签</td></tr><tr><td>Routes</td><td>提供一个路由出口，满足条件的路由组件，会渲染到组件内部</td></tr><tr><td>Route</td><td>用于指定路由组件和路由地址。path：路由组件对应的路径；element：路由组件；<strong>成对出现</strong></td></tr></tbody></table><h2 id="路由的执行过程">路由的执行过程</h2><ol><li class="lvl-3"><p>点击 Link 组件（a标签），修改了浏览器地址栏中的 url 。</p></li><li class="lvl-3"><p>React 路由监听到地址栏 url 的变化。</p></li><li class="lvl-3"><p>React 路由内部遍历所有 Route 组件，使用路由规则（ path ）与 pathname 进行匹配。</p></li><li class="lvl-3"><p>当路由规则（path）能够匹配地址栏中的 pathname 时，就展示该 Route 组件的内容。、</p></li></ol><h2 id="编程式导航">编程式导航</h2><p>注：上面使用 <Link to="/">跳转</Link> 的方式是：<strong>声明式导航</strong></p><p><strong>编程式导航</strong>: 通过 <strong>js 编程的方式进行路由页面跳转</strong>，比如说从首页跳转到关于页</p><h4 id="实现步骤："><strong>实现步骤</strong>：</h4><ol><li class="lvl-3"><p>导入一个 useNavigate 钩子函数</p></li><li class="lvl-3"><p>执行 useNavigate 函数 得到 跳转函数</p></li><li class="lvl-3"><p>在事件中执行跳转函数完成路由跳转</p></li></ol><h4 id="示例代码">示例代码</h4><pre><code class="language-javascript">// 导入useNavigate函数import &#123; useNavigate &#125; from 'react-router-dom'const Home = () =&gt; &#123;  // 执行函数  const navigate = useNavigate()  return (    &lt;div&gt;      Home      &lt;button onClick=&#123; ()=&gt; navigate('/about') &#125;&gt; 跳转关于页 &lt;/button&gt;    &lt;/div&gt;  )&#125; export default Home</code></pre><p>注: 如果在跳转时不<strong>想添加历史记录</strong>，可以添加额外参数 <strong>replace 为 true</strong></p><pre><code class="language-javascript">navigate('/about', &#123; replace: true &#125; )</code></pre><h2 id="路由传参-函数式组件的路由传参">路由传参(函数式组件的路由传参)</h2><p>跳转路由的同时，很多时候都需要传递参数，这里有两种传参方式：</p><h4 id="1-searchParams传参">1. searchParams传参</h4><p><strong>路由传参</strong></p><pre><code class="language-javascript"> navigate('/?id=1001&amp;name=zs', &#123; replace: true &#125;)</code></pre><p><strong>路由取参</strong></p><pre><code class="language-javascript">import &#123; useSearchParams &#125; from 'react-router-dom'// 在Home中读取页面传递过来的参数(以路径拼接的方式传递过来的参数)function Home () &#123;  const [params] = useSearchParams()  // params 是一个对象，对象里有一个get方法用来获取对应的参数  // 把参数的名称作为get方法的实参传递即可  const id = params.get('id')  const name = params.get('name')  return (    &lt;p&gt;这是首页的内容,首页获取到的参数id:&#123;id&#125;,name:&#123;name&#125;&lt;/p&gt;  )&#125;</code></pre><h4 id="2-params传参">2.params传参</h4><p><strong>路由传参</strong></p><pre><code class="language-javascript">    navigate('/about/1002/lisi', &#123; replace: true &#125;)</code></pre><p><strong>设置参数占位符</strong></p><pre><code class="language-javascript">&#123;/* 使用 params 传参和接收参数时，指定路由路径时需要提前使用“占位符”给参数进行占位 */&#125;&lt;Route path='/about/:id/:name' element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;</code></pre><p><strong>路由取参</strong></p><pre><code class="language-javascript">import &#123; useParams &#125; from 'react-router-dom'// 在关于页面接收登录页使用 params 传参的方式传递过来的参数function About () &#123;  const params = useParams()  return (    &lt;p&gt;这是关于的内容,接收到登录页传递过来的id为：&#123;params.id&#125;,name为&#123;params.name&#125;&lt;/p&gt;  )&#125;</code></pre><h2 id="404路由配置">404路由配置</h2><p>场景：当 url 的路径在整个路由配置中都找不到对应的 path ，使用404兜底组件进行渲染。</p><h4 id="实现步骤"><strong>实现步骤:</strong></h4><ol><li class="lvl-3"><p>准备一个 NotFound 组件（404的页面）</p></li><li class="lvl-3"><p>把该组件的路由对应关系配置为 <strong>Routes 内部的一级路由，path=‘*’</strong></p></li></ol><h4 id="示例代码-2"><strong>示例代码</strong></h4><pre><code class="language-javascript">import &#123; BrowserRouter, Routes, Route &#125; from 'react-router-dom' // 定义 404 组件const NotFound = () =&gt; &#123;  return (    &lt;h1&gt;404  抱歉,页面未找到TAT&lt;/h1&gt;  )&#125;function App () &#123;  return (    &lt;BrowserRouter&gt;      &lt;div className=&quot;App&quot;&gt;        &lt;Routes&gt;          &#123;/* 一级路由 */&#125;          &#123;/* 当所有路径都没有匹配到时渲染此组件 作为兜底 */&#125;          &lt;Route path='*' element=&#123;&lt;NotFound /&gt;&#125;&gt;&lt;/Route&gt;        &lt;/Routes&gt;      &lt;/div&gt;    &lt;/BrowserRouter&gt;  )&#125; export default App</code></pre><h2 id="Redirect-重定向">Redirect (重定向)</h2><pre><code class="language-javascript">1.一般写在所有路由注册的最下方,当所有路由都无法匹配时,跳转到Redirect指定的路由**2.具体编码:&lt;Routes&gt;         &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;            &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;            &lt;Redirect to=&quot;/about&quot;/&gt;          &lt;/Routes&gt;</code></pre><pre><code class="language-javascript">App.js代码修改 &#123;/* 注册路由 路由组件写法 */&#125; &lt;Routes&gt; &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt; &lt;Redirect to=&quot;/about&quot;/&gt; &lt;/Routes&gt;  记得引入 import &#123; Route,Routes,Redirect &#125; from 'react-router-dom'</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apifox的使用</title>
      <link href="/2024/01/24/Apifox%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/01/24/Apifox%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Apifox简介">Apifox简介</h2><p><strong>1.为什么要使用Apifox</strong></p><p>在当前行业发展背景下，绝大部分项目都是基于 前后端分离 的架构进行的，由前后端、测试、运维等不同的团队共同开发，那么团队之间能否很好的 协同合作 无疑直接决定着项目的最终效果。而协作其实也是大多数开发团队的痛点，为了便于团队协作，也出现了一些研发管理工具诸如 Jira、Teambition，应用也比较广泛，它们主要将功能聚焦于项目管理、代码托管、缺陷跟踪等环节。</p><p>但是在实际开发流程中，团队之间的协同是很低效的，比如需求评审结束之后，前后端进行接口定义并派一名工程师来定义 API 文档(一般使用 Swagger)；随后进入开发流程，后端按照 API 文档开发接口，在调试时还需按照文档在 Postman 中重新定义一遍；在后端开发出接口之前，前端如果需要开发就得按照 API 文档自己去 Mock 数据，也就是在 Mock.js 中重新写一遍接口定义和 Mock 规则；测试在接口开发完成之前需要按照文档到 JMeter 中写测试用例，难免的又得写一遍接口定义；</p><p><img src="https://s2.loli.net/2024/01/24/LclgiVtxToD1PYa.png" alt="image.png"></p><p>可以看到整个开发过程都是围绕 API 开展的，在这个过程中不同团队都需要对接口的定义进行操作，这会导致在联调时极易出现定义不一致等诸多问题。而且还用到了不同的工具如 Swagger、Postman、Mock、JMeter，明显造成了很多资源的浪费和低效使用。</p><p>而 Apifox 的诞生正是为了解决以上问题，Apifox 的研发宗旨—— 节省研发团队的每一分钟。<br><strong>2.Api First 理念下的开发流程</strong></p><p>Apifox 秉承的是 <code>API first</code>(API 优先)的先进理念，也就是开发团队首先制定 API，然后围绕 API 展开设计和开发。使用 Apifox 之后，开发效率会大大提升且各方工作体验更好，与外部团队的协作也会更加顺畅。在此理念下的开发流程是这样的：</p><p><strong>设计阶段</strong>：根据需求文档确定接口设计思路，接口设计者设计好接口初稿，然后前后端一起评审接口，完善接口文档。<br><strong>开发阶段</strong>：</p><p><strong>前端</strong>：Apifox 会根据接口文档自动生成 Mock 数据，直接进入开发过程无需手写 Mock 规则。<br><strong>后端</strong>：使用 Apifox 根据接口定义调试接口，即使在开发过程中接口有变化，调试时修改接口定义就可以自动更新文档。<br><strong>测试</strong>：使用后端调试时保存的接口用例生成测试用例。<br><strong>联调和测试阶段</strong>：此时所有接口开发完成，测试/后端使用集合测试功能进行多借口集成测试。</p><h2 id="上手操作-Apifox">上手操作 Apifox</h2><p><strong>1.编写接口文档</strong></p><p>点击“＋” --&gt; “新建接口”；</p><p><img src="https://s2.loli.net/2024/01/24/cJAnNMeLgFxV87D.png" alt="image.png"></p><p>如下是我新建的一个登录接口示例：</p><p><em>接口地址、接口基本信息</em></p><p><img src="https://s2.loli.net/2024/01/24/8pwfHqenBPLlgxX.png" alt="image.png"></p><p><em>请求参数设置</em></p><p><img src="https://s2.loli.net/2024/01/24/cZyke2C1fIS4Pnp.png" alt="image.png"></p><p><em>接口响应设置</em></p><p><img src="https://s2.loli.net/2024/01/24/nTEzec87IyPuUYh.png" alt="image.png"></p><p>设置完相关属性之后，点击保存，此时就会生成一个基于 Apifox 的接口文档，可以看到还可以运行此接口或者直接生成代码操作；</p><p><img src="https://s2.loli.net/2024/01/24/d2EIvQZjx4KtPgn.png" alt="image.png"></p><p><strong>2. 智能 Mock 数据</strong></p><p>可以看到在文档中有一个 Mock 区域，包含 Mock url；</p><p><img src="https://s2.loli.net/2024/01/24/f2xJslzLEomadvk.png" alt="image.png"></p><p>我们复制此 mock 地址，在浏览器打开，便可以直接访问到 mock 数据；</p><p><img src="https://s2.loli.net/2024/01/24/N8jIexBhpC63FyT.png" alt="image.png"></p><p>在 API 文档设定好之后就可以直接用这个 Mock 地址来做开发了。</p><p>(在后端还没有写好接口之前，前端可以利用mock出来的数据先开发，之后等后端工作完成后再将地址更换为后端的正式服务器地址)</p><p><strong>3.接口测试</strong></p><p>点击运行进入运行页面，点击自动生成的数据（或者自己填入想要测试的数据），点击发送即可</p><p><img src="https://s2.loli.net/2024/01/24/qY69bWumhTHvz8U.png" alt="image.png"></p><p>没有问题点击保存为用例</p><p><img src="https://s2.loli.net/2024/01/24/VUCThrHYQJ1L9vu.png" alt="image.png"></p><p>也可以设置特殊情况，来保存成为错误的用例</p><p><img src="https://s2.loli.net/2024/01/24/RVEro1Iac7gOtuW.png" alt="image.png"></p><p>也可以给测试的数据添加一些动态值来更好的处理一些情况</p><p><img src="https://s2.loli.net/2024/01/24/MGwpHiQJS8Luhv4.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Apifox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apifox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebStorage</title>
      <link href="/2023/12/10/WebStorage/"/>
      <url>/2023/12/10/WebStorage/</url>
      
        <content type="html"><![CDATA[<h2 id="一、WebStorage">一、WebStorage</h2><p>webStorage是本地存储的总称，它包括了<strong>localStorage</strong>和<strong>sessionStorage</strong>。本节内容向大家介绍的就是这两种本地存储的方法，以及它们之间的区别。</p><p>在学习本节之前我们先来看一下信息存储在浏览器中，我们可以在哪里看到：利用f12键打开控制台，在‘应用’中，可以查看到本地存储空间，这里会放置我们存储的一些本地信息，</p><h2 id="二、localStorage">二、localStorage</h2><p>该方法的调用者是window，先介绍它的使用格式，其中，xxx是它下面的api：</p><pre><code class="language-js">window.localStorage.xxx</code></pre><p>这里注意，window对象调用时，window是可以省略的。但是为了代码的完整性，在学习篇幅中并未省略window</p><h3 id="2-1-存储">2.1 存储</h3><p>我们可以将很多类型的信息存放在本地浏览器中，如字符串，对象，等等。（存进去的是字符串，存储内容一般5M左右，不同浏览器不同）是以键值对的形式存储的：</p><pre><code class="language-javascript">window.localStorage.setItem('key','value')</code></pre><p>如：</p><pre><code class="language-javascript"> window.localStorage.setItem('msg', 'hello')</code></pre><p><strong>注意</strong>：键和值必须都是字符串，如果不是字符串，会默认调用toString()方法</p><h4 id="新增对象">新增对象</h4><p>如果新增的不是一个字符串，而是一个对象呢，如果直接新增的话，肯定会被toString</p><pre><code class="language-javascript">window.localStorage.setItem('people', p)</code></pre><p>所以要使用JSON.stringify格式化处理下</p><pre><code class="language-javascript">window.localStorage.setItem('people', JSON.stringify(p))</code></pre><h3 id="2-2-读取">2.2 读取</h3><p>通过此方法我们可以读取到以及存储的数据，格式如下：</p><pre><code class="language-javascript">window.localStorage.getItem('key')</code></pre><p>如：</p><pre><code class="language-javascript">window.localStorage.getItem('msg2')</code></pre><p>console.log即可打印出来。</p><h3 id="2-3-删除">2.3 删除</h3><p>通过此方法我们可以删除本地存储的数据，格式如下：</p><pre><code class="language-javascript">window.localStorage.removeItem('key')</code></pre><p>如：</p><pre><code class="language-javascript">window.localStorage.removeItem('msg2')</code></pre><p>删除后数据则无法读取，读取出来的是null。</p><h3 id="2-4-清除全部">2.4 清除全部</h3><p>通过此方法可以清空本都存储的所有数据：</p><pre><code class="language-javascript">window.localStorage.clear()</code></pre><h3 id="2-5-像访问对象一样访问这些值">2.5 像访问对象一样访问这些值</h3><p>我们在使用过程中，经常用localStorage提供的<a href="https://so.csdn.net/so/search?q=setItem&amp;spm=1001.2101.3001.7020">setItem</a>和getItem方法来设置和获取值，其实还有另外的方式。</p><pre><code class="language-javascript">localStorage.test = '1';localStorage.test // '1'delete localStorage.test // 返回一个Boolean值，表示是否成功</code></pre><p>缺点是无法全部清空数据，需要遍历，手动删除</p><h3 id="2-5-代码">2.5 代码</h3><pre><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;localStorage&lt;/h2&gt;    &lt;button class=&quot;btn1&quot;&gt;点我保存一个数据&lt;/button&gt;    &lt;button class=&quot;btn2&quot;&gt;点我读取一个数据&lt;/button&gt;    &lt;button class=&quot;btn3&quot;&gt;点我删除一个数据&lt;/button&gt;    &lt;button class=&quot;btn4&quot;&gt;清空所有数据&lt;/button&gt;    &lt;script&gt;        let p = &#123;name: '张三', age: '18'&#125;        var btn1 = document.querySelector('.btn1')        var btn2 = document.querySelector('.btn2')        var btn3 = document.querySelector('.btn3')        var btn4 = document.querySelector('.btn4')        btn1.addEventListener('click', function() &#123;             window.localStorage.setItem('msg', 'hello')             window.localStorage.setItem('msg2', '666')             window.localStorage.setItem('people', JSON.stringify(p))        &#125;)        btn2.addEventListener('click', function() &#123;            console.log(window.localStorage.getItem('msg2'))            console.log(window.localStorage.getItem('people'))        &#125;)        btn3.addEventListener('click', function() &#123;            window.localStorage.removeItem('msg2')        &#125;)        btn4.addEventListener('click', function() &#123;            window.localStorage.clear()        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="三，sessionStorage">三，sessionStorage</h2><h3 id="3-1-用法">3.1 用法</h3><p>sessionStorage内部的四个api和localStorage的用法完全一样。</p><h3 id="3-2-区别">3.2 区别</h3><p>两者都是本地存储，区别在于：<br>localStorage的存储内容，需要手动清除才会消失，关闭浏览器后再次点开话可以获取到；<br>sessionStorage的存储内容会随着浏览器关闭而关闭，再次点开无法看到。</p><h3 id="3-3-代码">3.3 代码</h3><pre><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;sessionStorage&lt;/h2&gt;    &lt;button class=&quot;btn1&quot;&gt;点我保存一个数据&lt;/button&gt;    &lt;button class=&quot;btn2&quot;&gt;点我读取一个数据&lt;/button&gt;    &lt;button class=&quot;btn3&quot;&gt;点我删除一个数据&lt;/button&gt;    &lt;button class=&quot;btn4&quot;&gt;清空所有数据&lt;/button&gt;    &lt;script&gt;        let p = &#123;name: '张三', age: '18'&#125;        var btn1 = document.querySelector('.btn1')        var btn2 = document.querySelector('.btn2')        var btn3 = document.querySelector('.btn3')        var btn4 = document.querySelector('.btn4')        btn1.addEventListener('click', function() &#123;             window.sessionStorage.setItem('msg', 'hello')             window.sessionStorage.setItem('msg2', '666')             window.sessionStorage.setItem('people', JSON.stringify(p))        &#125;)        btn2.addEventListener('click', function() &#123;            console.log(sessionStorage.getItem('msg2'))        &#125;)        btn3.addEventListener('click', function() &#123;            window.sessionStorage.removeItem('msg2')        &#125;)        btn4.addEventListener('click', function() &#123;            window.sessionStorage.clear()        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="四、StorageEvent">四、StorageEvent</h2><p>当前页面使用的 storage 被其他页面修改时会触发 StorageEvent 事件。</p><pre><code>window.addEventListener('storage', function(e) &#123;// e.key 变动的key// e.oldValue 旧值// e.newValue 新值// e.storageArea 被操作的 storage 对象// e.url 发生改变的对象所在文档的 URL 地址&#125;);</code></pre><p><strong>同一个页面的事件，无法监听</strong></p><p><strong>事件在同一个域下的不同页面之间触发，即在 A 页面注册了 storge 的监听处理，只有在跟 A 同域名下的 B 页面操作 storage 对象，A 页面才会被触发 storage 事件</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> webstorage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js实现继承的6种方式</title>
      <link href="/2023/11/24/js%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/11/24/js%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="目录">目录</h2><p>-<a href="#1.%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF">原型链继承</a><br>-<a href="#2.%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF">借用构造函数继承</a><br>-<a href="#3.%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%A7%E6%89%BF%EF%BC%89">组合继承（经典继承）</a><br>-<a href="#4.%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF">原型式继承</a><br>-<a href="#5.%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF">寄生式继承</a><br>-<a href="#6.%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF">寄生组合式继承寄生式继承</a></p><blockquote><p>JavaScript想实现继承的目的：重复利用另外一个对象的属性和方法。</p></blockquote><h2 id="1-原型链继承">1.原型链继承</h2><blockquote><p>让一个构造函数的原型是另一个类型的实例，那么这个构造函数new出来的实例就具有该实例的属性。<br>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p></blockquote><pre><code class="language-js">function Parent() &#123;   this.isShow = true   this.info = &#123;       name: &quot;xyy&quot;,       age: 18,   &#125;;&#125; Parent.prototype.getInfo = function() &#123;   console.log(this.info);   console.log(this.isShow);&#125; function Child() &#123;&#125;;Child.prototype = new Parent();//prototype属性是这个函数所创建的实例的原型对象  let Child1 = new Child();//new关键词实例化该构造函数Child1.info.gender = &quot;男&quot;;//在Child1的原型（一个Parent实例）上增加了一个gender属性Child1.getInfo(); // &#123;name: 'xyy', age: 18, gender: '男'&#125; ture let child2 = new Child();child2.isShow = false//直接在child2上添加了一个属性isShowconsole.log(child2.info.gender) // 男child2.getInfo(); // &#123;name: 'xyy', age: 18, gender: '男'&#125; false</code></pre><p>优点：写法方便简洁，容易理解。</p><p>缺点：对象实例共享所有继承的属性和方法。传教子类型实例的时候，不能传递参数，因为这个对象是一次性创建的（没办法定制化）。</p><h2 id="2-借用构造函数继承">2.借用构造函数继承</h2><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p><pre><code class="language-javascript">function Parent1()&#123;    this.name = 'parent1';  &#125;   Parent1.prototype.getName = function () &#123;    return this.name;  &#125;   function Child1()&#123;    Parent1.call(this);    this.type = 'child1'  &#125;   let child = new Child1();  console.log(child);  // 没问题  console.log(child.getName());  // 会报错</code></pre><p>特点：<br>1.解决了1中，子类实例共享父类引用属性的问题<br>2.创建子类实例时，可以向父类传递参数<br>3.可以实现多继承（call多个父类对象）</p><p>缺点：<br>1.实例并不是父类的实例，只是子类的实例<br>2.只能继承父类的实例属性和方法，不能继承原型属性/方法<br>3.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p><h2 id="3-组合继承（经典继承）">3.组合继承（经典继承）</h2><blockquote><p>将 原型链 和 借用构造函数 的组合到一块。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性</p></blockquote><pre><code class="language-javascript">function Person(gender) &#123;  console.log('执行次数');  this.info = &#123;    name: &quot;喜羊羊&quot;,    age: 19,    gender: gender  &#125;&#125; Person.prototype.getInfo = function () &#123;   // 使用原型链继承原型上的属性和方法  console.log(this.info.name, this.info.age)&#125; function Child(gender) &#123;  Person.call(this, gender) // 使用构造函数法传递参数&#125; Child.prototype = new Person()//重点是这一步 让Child的原型是一个Person实例 let child1 = new Child('男');child1.info.nickname = '小喜'child1.getInfo()console.log(child1.info); let child2 = new Child('女');console.log(child2.info);</code></pre><blockquote><p>执行次数输出几次？</p></blockquote><p>优点: 解决了原型链继承和借用构造函数继承造成的影响。</p><p>缺点: 无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部</p><h2 id="4-原型式继承">4.原型式继承</h2><p>方法一：<br>借用构造函数在一个函数A内部创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。</p><p>本质上，函数A是对传入的对象执行了一次浅复制。</p><pre><code class="language-javascript">function createObject(obj) &#123;  function Fun() &#123;&#125;  Fun.prototype = obj  return new Fun()&#125; let person = &#123;  name: '喜羊羊',  age: 18,  hoby: ['唱', '跳'],  showName() &#123;    console.log('my name is:', this.name)  &#125;&#125; let child1 = createObject(person)//相当于让person是child1的原型child1.name = 'xxxy'child1.hoby.push('rap')let child2 = createObject(person) console.log(child1)//Fun &#123;name: 'xxxy'&#125;console.log(child2)//Fun &#123;&#125;console.log(person.hoby) // ['唱', '跳', 'rap']</code></pre><p>方法二：Object.create()</p><blockquote><p>Object.create() 是把现有对象的属性，挂到新建对象的原型上，新建对象为空对象<br>ECMAScript 5通过增加Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，Object.create()与这里的函数A方法效果相同。</p></blockquote><pre><code class="language-javascript">let person = &#123;  name: 'mjy',  age: 19,  hoby: ['唱', '跳'],  showName() &#123;    console.log('my name is: ', this.name)  &#125;&#125; let child1 = Object.create(person)child1.name = 'xxt'child1.hoby.push('rap')let child2 = Object.create(person) console.log(child1)console.log(child2)console.log(person.hoby) // ['唱', '跳', 'rap']</code></pre><h2 id="5-寄生式继承">5.寄生式继承</h2><blockquote><p>寄生式继承的思路与(寄生) <code>原型式继承</code> 和 <code>工厂模式</code> 似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象。</p></blockquote><pre><code class="language-javascript">function objectCopy(obj) &#123;  function Fun() &#123; &#125;;  Fun.prototype = obj;  return new Fun();&#125; function createAnother(obj) &#123;  let clone = objectCopy(obj);//obj是clone 这个实例的原型  clone.showName = function () &#123;    console.log('my name is：', this.name);  &#125;;  return clone;&#125; let person = &#123;     name: &quot;myy&quot;,     age: 18,     hoby: ['唱', '跳']&#125; let child1 = createAnother(person);child1.hoby.push(&quot;rap&quot;);console.log(child1.hoby); // ['唱', '跳', 'rap']child1.showName(); // my name is： myy let child2 = createAnother(person);console.log(child2.hoby); // ['唱', '跳', 'rap']</code></pre><p>优点：写法简单，不需要单独创建构造函数。</p><p>缺点：通过寄生式继承给对象添加函数会导致函数难以重用。使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似.</p><h2 id="6-寄生组合式继承">6.寄生组合式继承</h2><blockquote><p>前面讲过，组合继承是常用的经典继承模式，不过，组合继承最大的问题就是无论什么情况下，都会调用两次父类构造函数；一次是在创建子类型的时候，一次是在子类型的构造函数内部。寄生组合继承就是为了降低父类构造函数的开销而实现的。</p></blockquote><p>通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p><pre><code class="language-javascript">function objectCopy(obj) &#123;  function Fun() &#123; &#125;;  Fun.prototype = obj;  return new Fun();&#125; function inheritPrototype(child, parent) &#123;  let prototype = objectCopy(parent.prototype);//parent.prototype 是 prototype这个实例的原型 本例中调用该函数时panrent.prototype上只有一个showName方法  prototype.constructor = child;  //让prototype的constructor方法为child  child.prototype = prototype;&#125; function Parent(name) &#123;  this.name = name;  this.hoby = ['唱', '跳']&#125; Parent.prototype.showName = function () &#123;  console.log('my name is：', this.name);&#125; function Child(name, age) &#123;  Parent.call(this, name);//将Parent属性复制进来  this.age = age;&#125; inheritPrototype(Child, Parent);Child.prototype.showAge = function () &#123;  console.log('my age is：', this.age);&#125; let child1 = new Child(&quot;xyy&quot;, 18);child1.showAge(); // 18child1.showName(); //xyychild1.hoby.push(&quot;rap&quot;);console.log(child1.hoby);  let child2 = new Child(&quot;myy&quot;, 18);child2.showAge(); // 18child2.showName(); // myyconsole.log(child2.hoby); </code></pre><blockquote><p>两行输出的是什么？</p></blockquote><p><img src="image.png" alt="Alt text"><br>优点是：高效率只调用一次父构造函数，并且因此避免了在子原型上面创建不必要，多余的属性。与此同时，原型链还能保持不变；</p><p>缺点是：代码复杂</p><h2 id="ES6-提供了继承的关键字-extends">ES6 提供了继承的关键字 extends</h2><pre><code class="language-javascript">class Person &#123;  constructor(name) &#123;    this.name = name  &#125;  // 原型方法  // 即 Person.prototype.getName = function() &#123; &#125;  // 下面可以简写为 getName() &#123;...&#125;  getName = function () &#123;    console.log('Person:', this.name)  &#125;&#125; class Gamer extends Person &#123;  constructor(name, age) &#123;    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。    super(name)//通过super(name)调用了父类的构造函数 并且传入了name参数    this.age = age  &#125;&#125; const asuna = new Gamer('Asuna', 20)asuna.getName() // 成功访问到父类的方法</code></pre>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/22/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%AE%83%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/10/22/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%AE%83%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1>图片懒加载的定义以及实现它的几种方式</h1><h2 id="图片懒加载是什么">图片懒加载是什么</h2><p>类似于大型的淘宝商城、京东等网页，设计大量的商品图片信息，如果我们使页面包含的所有图片一次性加载完成，那用户体验很差。目前流行的做法是滚动动态加载，也就是懒加载，显示在屏幕之外的图片默认不加载，随着页面的滚动，图片进入了显示的范围，则触发图片的加载显示这样做的好处，一是页面加载速度快(浏览器进度条和加载转圈很快就结束了，这样用户的体验也比较好)，二是节省流量，因为不可能每一个用户会把页面从上到下滚动完</p><h2 id="如何实现">如何实现</h2><h4 id="1-js方法">1. js方法</h4><p>js方法，利用滚动事件，判断当时的图片位置是否在可视框内，然后进行渲染。</p><p>1.存储图片的真实路径，把图片的真实路径绑定给一个以data开头的自定义属性data-url即可，页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片（没有请求就提高了性能）</p><pre><code class="language-html">&lt;div class=&quot;scrollLoading&quot; data-url=&quot;loaded.html&quot;&gt;加载中...&lt;/div&gt;</code></pre><p>2.初始化img的时候，src不能是真实的图片地址(会一次性发送请求)，也不可以是空地址或者坏地址(会出现出错图标，如下所示：）</p><p><img src="https://img-blog.csdnimg.cn/cc9751857bf646388d204cf38a5dd3c4.png" alt="在这里插入图片描述"></p><p>3.设置img的默认src为一张1px*1px，很小很小的gif透明图片（所有的img都用这一张，只会发送一次请求），之所以需要是透明的，是需要透出通过background设置的背景图(一张loading.png，就是一个转圈圈的背景效果图)</p><p>4.需要一个滚动事件，判断元素是否在浏览器窗口，一旦进入视口才进行加载，当滚动加载的时候，就把这张透明的1px.gif图片替换为真正的url地址（也就是data-url里保存的值）</p><pre><code class="language-html">&lt;img  data-url=&quot;xxx&quot; src=&quot;1px.gif&quot; width=&quot;180&quot; height=&quot;180&quot; style=&quot;background:url(loading.gif) no-repeat center;&quot; /&gt;</code></pre><p>5.等到图片进入视口后，利用js提取data-url的真实图片地址赋值给src属性，就会去发送请求加载图片，真正实现了按需加载</p><p><strong>弊端：代码冗杂，你还要去监听页面的滚动事件，这本身就是一个不建议监听的事件，即便是我们做了节流或防抖</strong></p><p><strong>具体操作</strong></p><h4 id="1-获取可视窗口的大小">1.获取可视窗口的大小</h4><p>IE9和其他浏览器提供了innerWidth 和 innerHeight属性获取当前浏览器窗口的大小</p><p>IE8及更早版本以前没有提供取得浏览器窗口大小的属性，不过提供了dom页面可见区域的属性，即<br>document.documentElement.clientHeight<br>document.documentElement.clientWidth<br>元素的客户区大小（client dimension），指的是元素内容及其内边距所占据的空间大小。有关客户区 大小的属性有两个：clientWidth 和 clientHeight。其中，clientWidth 属性是元素内容区宽度加 上左右内边距宽度；clientHeight 属性是元素内容区高度加上上下内边距高度</p><p>IE6中，上述属性必须在标准模式才有效，如果是混杂模式，需要通过document.body.clientWidth 和 document.body. clientHeight 取得相同信息。</p><p>代码实现：</p><pre><code>var pageWidth = window.innerWidth,  pageHeight = window.innerHeight;  if (typeof pageWidth != &quot;number&quot;)&#123;  //pageWidth的值不是数值，说明没有innerwidth属性 if (document.compatMode == &quot;CSS1Compat&quot;)&#123; //标准模式 pageWidth = document.documentElement.clientWidth;  pageHeight = document.documentElement.clientHeight;  &#125; else &#123; //混在模式 pageWidth = document.body.clientWidth;  pageHeight = document.body.clientHeight;  &#125; &#125;</code></pre><h4 id="2-获取内容滚动的距离">2. 获取内容滚动的距离</h4><p><img src="https://img-blog.csdnimg.cn/a877e1cd71804b65a3e90d45df2ad56a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFyYWJpdXo=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="3-如何判断图片进入了可视区域">3. 如何判断图片进入了可视区域</h4><p><img src="https://img-blog.csdnimg.cn/b2af1c682cbe4b58a83236ef899c459e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFyYWJpdXo=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>上图蓝色部分表示视口大小，可以想象成手机屏幕，蓝色区域的高度和宽度也就是视口的高度和宽度，用innerHeight和innerWidth来表示外面的大黑色框框表示内容的大小(手机屏幕那么小宽度不可能装下所有的网页内容，所以会有“溢出”，可以用scrollTop和scrollLeft表示上面和左边溢出的部分)<br>绿色的小方框表示图片，图片的顶部到内容的顶部称为图片的offsetTop<br>那么很明显，若内容上方偏移量(scrollTop)+视口高度(innerHeight)&gt;图片距离内容顶部的偏移量(offsetTop)，则说明图片在视口内，否则说明图片在视口外。</p><h3 id="二、使用-content-visibility-auto-实现图片内容的延迟渲染">二、使用 <code>content-visibility: auto</code> 实现图片内容的延迟渲染</h3><p>首先，介绍一个非常有用，但是相对较为冷门的属性 – <code>content-visibility</code>。</p><p><code>content-visibility</code>：属性控制一个元素是否渲染其内容，它允许用户代理（浏览器）潜在地省略大量布局和渲染工作，直到需要它为止。</p><p>利用 <code>content-visibility</code> 的特性，我们可以实现<strong>如果该元素当前不在屏幕上，则不会渲染其后代元素</strong>。</p><p>假设我们有这样一个 DEMO：</p><pre><code class="language-html">&lt;div class=&quot;g-wrap&quot;&gt;    // 模块 1       &lt;div class=&quot;paragraph&quot;&gt;             &lt;p&gt;Lorem Start!&lt;/p&gt;              &lt;img src=&quot;https://s1.ax1x.com/2023/02/20/pSX1xMV.png&quot; alt=&quot;&quot; /&gt;            &lt;p&gt;Lorem End!&lt;/p&gt;         &lt;/div&gt;    // 模块 2      &lt;div class=&quot;paragraph&quot;&gt;          &lt;p&gt;Lorem Start!&lt;/p&gt;                &lt;img src=&quot;https://s1.ax1x.com/2023/02/20/pSX1xMV.png&quot; alt=&quot;&quot; /&gt;           &lt;p&gt;Lorem End!&lt;/p&gt;       &lt;/div&gt;    // ... 连续几十个上述类似的结构&lt;/div&gt;</code></pre><p>只需要给需要延迟（实时）渲染的元素，设置简单的 CSS 样式：</p><pre><code>.paragraph &#123;    content-visibility: auto;&#125;</code></pre><h3 id="content-visibility-auto-VS-图片懒加载"><code>content-visibility: auto</code> VS 图片懒加载</h3><p>当然，其实使用 <code>content-visibility: auto</code> 并不能真正意义上实现图片的懒加载。</p><p>这是因为，即便当前页面可视区域外的内容未被渲染，但是图片资源的 HTTP/HTTPS 请求，依然会在页面一开始被触发！</p><p>因此，这也得到了一个非常重要的结论：</p><p><code>content-visibility: auto</code> <strong>无法直接替代图片懒加载，设置了 <code>content-visibility: auto</code> 的元素在可视区外只是未被渲染，但是其中的静态资源仍旧会在页面初始化的时候被全部加载</strong>。因此，它更像是一个虚拟列表的替代方案。</p><h3 id="三、使用-loading-lazy-HTML-属性实现图片懒加载">三、使用 <code>loading=lazy</code> HTML 属性实现图片懒加载</h3><p>OK，<code>content-visibility</code> 很不错，但是略有瑕疵。但是，我们还有其他方式。</p><p>HTML5 新增了一个 <code>loading</code> 属性。</p><p>到今天，除了 IE 系列浏览器，目前都支持通过 <code>loading</code> 属性实现延迟加载。此属性可以添加到 <code>&lt;img&gt;</code> 元素中，也可以添加到 <code>&lt;iframe&gt;</code> 元素中。</p><p>属性的值为 <code>loading=lazy</code> 会告诉浏览器，如果图像位于可视区时，则立即加载图像，并在用户滚动到它们附近时获取其他图像。</p><p>我们可以像是这样使用它：</p><pre><code>&lt;img src=&quot;xxx.png&quot; loading=&quot;lazy&quot;&gt;</code></pre><p><strong>这样，便可以非常便捷的实现图片的懒加载，省去了添加繁琐的 JavaScript 代码的过程</strong>。</p><h3 id="四、使用-decoding-async-实现图片的异步解码">四、使用 <code>decoding=async</code> 实现图片的异步解码</h3><p>除了 <code>loading=lazy</code>，HTML5 还新增了一个非常有意思的属性增强图片的用户体验。那就是 <code>decoding</code> 属性。</p><p>HTMLImageElement 接口的 <code>decoding</code> 属性用于告诉浏览器使用何种方式解析图像数据。</p><p>它的可选取值如下：</p><ul class="lvl-0"><li class="lvl-2"><p><code>sync</code>: 同步解码图像，保证与其他内容一起显示。</p></li><li class="lvl-2"><p><code>async</code>: 异步解码图像，加快显示其他内容。</p></li><li class="lvl-2"><p><code>auto</code>: 默认模式，表示不偏好解码模式。由浏览器决定哪种方式更适合用户。</p></li></ul><p>上文其实也提及了，浏览器在进行图片渲染展示的过程中，是需要对图片文件进行解码的，这一个过程快慢与图片格式有关。</p><p>而如果我们不希望图片的渲染解码影响页面的其他内容的展示，可以使用 <code>decoding=async</code> 选项，像是这样：</p><pre><code>&lt;img src=&quot;xxx.png&quot; decoding=&quot;async&quot;&gt;</code></pre><p>这样，浏览器便会异步解码图像，加快显示其他内容。这是图片优化方案中可选的一环。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/22/%E4%BB%80%E4%B9%88%E6%98%AFBFC%E4%BB%A5%E5%8F%8ABFC%E7%9A%84%E7%94%A8%E9%80%94/"/>
      <url>/2023/10/22/%E4%BB%80%E4%B9%88%E6%98%AFBFC%E4%BB%A5%E5%8F%8ABFC%E7%9A%84%E7%94%A8%E9%80%94/</url>
      
        <content type="html"><![CDATA[<h1>什么是BFC以及BFC的用途</h1><h2 id="什么是BFC">什么是BFC</h2><h3 id="定义">定义</h3><p><strong>BFC - Block Formatting Context 块级格式化上下文</strong></p><p>BFC的定义，在官方文档到中是这么介绍的：一个BFC区域包含创建该上下文元素的所有子元素，但是不包括创建了新的BFC的子元素的内部元素，BFC是一块块独立的渲染区域，可以将BFC看成是元素的一种属性，拥有了这种属性的元素就会使他的子元素与世隔绝，不会影响到外部其他元素</p><pre><code class="language-html">&lt;div class=&quot;box1&quot; id=&quot;HM_bfc1&quot;&gt;     &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;     &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;     &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt;     &lt;div class=&quot;box5&quot; id=&quot;HM_bfc2&quot;&gt;         &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt;         &lt;div class=&quot;box7&quot;&gt;&lt;/div&gt;         &lt;div class=&quot;box8&quot;&gt;&lt;/div&gt;     &lt;/div&gt;&lt;/div&gt;</code></pre><p>用这段代码来解释上面那段BFC定义的话，就应该是这个意思：#HM_bfc1是一块BFC区域，这块区域包含了box2、box3、box4、box5，也就是所有#HM_bfc1的子元素。同时#HM_bfc2也创造了一块BFC区域，包含了box6，box7，box8。注意，第一个box1的BFC，只包括box1的子元素box2345，不包括box678。#HM_bfc2这个BFC同样也仅仅是包括自己的子元素box678。</p><p>划重点</p><ol><li class="lvl-3"><p><strong>每一个BFC区域只包括其子元素，不包括其子元素的子元素</strong>。(这1点比较容易理解)</p></li><li class="lvl-3"><p><strong>每一个BFC区域都是独立隔绝的,互不影响！</strong>(这点不太好理解，但是后续会使用代码验证)</p></li></ol><h3 id="触发BFC">触发BFC</h3><p>并不是任意一个元素都可以被当做BFC，只有当这个元素满足以下任意一个条件的时候，这个元素才会被当做一个BFC。</p><p><strong>触发BFC的条件</strong></p><ul class="lvl-0"><li class="lvl-2"><p>body根元素</p></li><li class="lvl-2"><p>设置浮动，不包括none</p></li><li class="lvl-2"><p>设置定位，absoulte或者fixed</p></li><li class="lvl-2"><p>行内块显示模式，inline-block</p></li><li class="lvl-2"><p>设置overflow，即hidden，auto，scroll</p></li><li class="lvl-2"><p>表格单元格，table-cell</p></li><li class="lvl-2"><p>弹性布局，flex</p></li></ul><h2 id="利用BFC解决问题">利用BFC解决问题</h2><p>在你明白了解BFC的触发规则之后，那么就需要利用BFC的特点来解决我们在布局中遇到的一些问题了，还记得我们之前说过，BFC有一个特点是：<strong>每一个BFC区域都是相互独立，互不影响的。</strong></p><h4 id="1-解决外边距的塌陷问题（垂直塌陷）">1 解决外边距的塌陷问题（垂直塌陷）</h4><p>开发中，前端的布局手段，离不开外边距margin，那么，也会遇到一些问题，例如外边距的垂直塌陷问题。</p><p><img src="https://img-service.csdnimg.cn/img_convert/2ad70ebd41da218012adfca472838b0b.png" alt="img"></p><p>通过以上的实例，我们会发现，代码给两个div盒子，都添加了四个方向的margin，讲道理，学过数学的都知道，100+100=200.可是，盒子之间的距离，现在却之后100px。这就是很典型的margin的塌陷，两段margin重叠到了一块，互相影响。那么，如何利用BFC，让这个问题得到解决呢。回忆下，上文说过，BFC，就是一个与世隔绝的独立区域，不会互相影响，那么，我们可以将这两个盒子，放到两个BFC区域中，即可解决这个问题。</p><p><img src="https://img-service.csdnimg.cn/img_convert/7624be2cd5cbe19138b8ed201dabdfe3.png" alt="img"></p><h4 id="2-利用BFC解决包含塌陷">2 利用BFC解决包含塌陷</h4><p>当父子关系的盒子，给子元素添加margin-top，有可能会把父元素一起带跑</p><p><img src="https://img-service.csdnimg.cn/img_convert/f4ab05b30df912f1a7cc9dcf5e1f930e.png" alt="img"></p><p>原本，正确的显示方式，应该是粉色盒子与红色盒子的顶部距离为50px，但是由于margin的塌陷问题，导致盒子内部的布局影响到了外部。这个时候，就可以触发BFC，将父盒子变成一个独立的区域，这样在BFC区域内部的任何操作，都不会影响到外部。</p><p><img src="https://img-service.csdnimg.cn/img_convert/dae850fd2ef84d2d346dfa13aa3f02d4.png" alt="img"></p><h4 id="3-当浮动产生影响的时候，可以利用BFC来清除浮动的影响">3 当浮动产生影响的时候，可以利用BFC来清除浮动的影响</h4><p><img src="https://img-service.csdnimg.cn/img_convert/7a193a37b6257a33621a2f9fa8d96436.png" alt="img"></p><p>以上代码表示，一个没有设置高度的父盒子，包含着七个子元素。如果此时，所有的子元素都浮动的话。</p><p><img src="https://img-service.csdnimg.cn/img_convert/de849a7c6dd4752b6d0cdff45ede40e7.png" alt="img"></p><p>当所有的子元素都浮动了，这个时候，父盒子失去了原有的高度，这就是浮动的影响。这个时候，同样也可用BFC的机制，来清除浮动带来的影响。使用BFC，将所有的浮动元素包裹起来。</p><h4 id="4-BFC可以阻止标准流元素被浮动元素覆盖">4 BFC可以阻止标准流元素被浮动元素覆盖</h4><p><img src="https://img-service.csdnimg.cn/img_convert/bc71c7ec9908e03c98e2e2cbc2443113.png" alt="img"></p><p><strong>大家都知道，浮动的元素会脱离文档流，跑到上一个层面，也就是和原本的元素们不在一个层面了。所以可能会导致浮动元素覆盖基本元素的问题。</strong></p><p><strong>那么这个时候我们只需要让蓝色区域触发BFC，就可以做到不受浮动元素影响</strong></p><p><img src="https://img-blog.csdnimg.cn/0f588409de024b86a030e129e714838e.png" alt="在这里插入图片描述"></p><p>当蓝色盒子触发了BFC之后，浮动元素再也不能覆盖它了，而且还能利用这个特性，来实现蓝色盒子宽度根据红色盒子的宽度来做自动适应</p><h3 id="总结">总结</h3><ul class="lvl-0"><li class="lvl-2"><p>一个BFC区域只包含其子元素，不包括其子元素的子元素.</p></li><li class="lvl-2"><p>并不是所有的元素都能成为一块BFC区域，只有当这个元素满足条件的时候才会成为一块BFC区域</p></li><li class="lvl-2"><p>不同的BFC区域之间是相互独立的，互不影响的。利用这个特性我们可以让不同BFC区域之间的布局不产生影响.</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/11/%E7%9B%B4%E6%92%AD/"/>
      <url>/2023/09/11/%E7%9B%B4%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="前端组组别介绍">前端组组别介绍</h2><h3 id="前端是什么？">前端是什么？</h3><p>前端即网站前台部分，运行在PC端，移动端等浏览器上展现给用户浏览的网页。随着互联网技术的发展，HTML5，CSS3，前端框架的应用，跨平台响应式网页设计能够适应各种屏幕分辨率，合适的动效设计，给用户带来极高的用户体验。(摘自百度百科)</p><p>用我自己的话说，前端组所做的工作大多是我们能看见的部分，比如网页的布局，动画，还有网页上的信息，都需要我们前端通过代码来呈现。在一个项目落地的过程中，前端在团队中扮演的是将设计组绘制好的设计图通过代码实现成我们能看得到的网页，并且完成产品组要求的交互功能及效果的一个角色。<br>在我眼里，前端是一个极其可视化的工作。</p><h3 id="前端能做什么？">前端能做什么？</h3><p>我们主要是做<strong>小程序</strong>以及<strong>网页</strong>。<br>其实也可以通过一些框架将前端代码转化，实现<strong>移动端APP</strong>。</p><p>所以前端其实还是蛮全能的hhhhh，你们用的我们都可以做。</p><h3 id="前端需要学什么？">前端需要学什么？</h3><p>前端从代码构成来说分为HTML、CSS、JS（JavaScript）三个部分，分别负责一个方面的功能：</p><p>HTML用来描述网页的文档结构，用来当作网页内容的容器。代码中包含 &lt;&gt; 或者 &lt;&gt;…&lt;/&gt; 的都是HTML代码；</p><p>CSS用来描述网页的外观特征，比如排版、外形、颜色等；</p><p>JS主要两个功能：动态的控制网页 &amp; 实现通信交互；（JS可以直接操作html和css，功能非常强大，所以在前端学习中js需要投入更多的精力）</p><p><img src="https://s2.loli.net/2023/09/11/lZNSpAfj5hKiFYC.jpg" alt="IMG_9954_20230904-230314_.JPG"><br>（前端学习路线图）</p><p>直播中我们主要会学习一些基础的html和css</p><h2 id="入门知识教学">入门知识教学</h2><h3 id="开发工具">开发工具</h3><p>chrome浏览器  <a href="https://www.google.cn/chrome/index.html">https://www.google.cn/chrome/index.html</a></p><p>visual studio code （简称vscode）<br><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p>配置中文界面，下载live server插件查看实时代码效果</p><p>教程链接：<br>菜鸟教程 <a href="https://www.runoob.com/">https://www.runoob.com/</a></p><p>w3school <a href="https://www.w3school.com.cn/">https://www.w3school.com.cn/</a></p><h3 id="教学–写一个简单的注册信息静态页面">教学–写一个简单的注册信息静态页面</h3><h4 id="什么是html">什么是html</h4><p>HTML 是用来描述网页的一种语言。HTML 是一种在 Web 上使用的通用标记语言。HTML 允许你格式化文本，添加图片，创建链接、输入表单、框架和表格等等，并可将之存为文本文件，浏览器即可读取和显示。</p><ul class="lvl-0"><li class="lvl-2"><p>HTML 指的是超文本标记语言: HyperText Markup Language</p></li><li class="lvl-2"><p>HTML 不是一种编程语言，而是一种标记语言</p></li><li class="lvl-2"><p>标记语言是一套标记标签 (markup tag)</p></li><li class="lvl-2"><p>HTML 使用标记标签来描述网页</p></li><li class="lvl-2"><p>HTML 文档包含了HTML 标签及文本内容</p></li><li class="lvl-2"><p>HTML文档也叫做 web</p></li></ul><p>代码：</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;        &lt;style&gt;         form&#123;            background-color: bisque;        &#125;        #sex&#123;            color: red;        &#125;        .hobby&#123;            color: blue;        &#125;        &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt;&lt;p&gt;姓名:&lt;input type=&quot;text&quot; /&gt;&lt;p /&gt;&lt;p&gt;登录名:&lt;input type=&quot;text&quot; /&gt;(可包含a-z,0-9和下划线)&lt;p /&gt;&lt;p&gt;密码:&lt;input type=&quot;password&quot; /&gt;(至少包含6个字符)&lt;p /&gt;&lt;p&gt;确认密码:&lt;input type=&quot;password&quot; /&gt;&lt;p /&gt;&lt;p id=&quot;sex&quot;&gt;性别:&lt;input type=&quot;radio&quot;/&gt;男&lt;input type=&quot;radio&quot; /&gt;女&lt;p /&gt;&lt;p class=&quot;hobby&quot;&gt;爱好: &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;sport&quot; /&gt;运动&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;chat&quot; /&gt;聊天&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;play&quot; /&gt;玩游戏&lt;p /&gt;&lt;p&gt;职业:&lt;select name=&quot;career&quot;&gt;&lt;option value=&quot;engineer&quot;&gt;工程师&lt;/option&gt;&lt;option value=&quot;teacher&quot;&gt;教师&lt;/option&gt;&lt;option value=&quot;doctor&quot;&gt;医生&lt;/option&gt;&lt;/select&gt;&lt;p /&gt;&lt;b&gt;阅读淘宝网协议&lt;/b&gt;&lt;br /&gt;&lt;textarea name=&quot; protocol&quot; cols=&quot;50&quot; rows=&quot;5&quot; value=&quot;&quot;&gt;淘宝平台服务协议                                                                                             最新版本生效日期：2019年08月19日提示条款欢迎您与各淘宝平台经营者（详见定义条款）共同签署本《淘宝平台服务协议》（下称“本协议”）并使用淘宝平台服务！本协议为《淘宝服务协议》修订版本，自本协议发布之日起，淘宝平台各处所称“淘宝服务协议”均指本协议。各服务条款前所列索引关键词仅为帮助您理解该条款表达的主旨之用，不影响或限制本协议条款的含义或解释。为维护您自身权益，建议您仔细阅读各条款具体表述。【审慎阅读】您在申请注册流程中点击同意本协议之前，应当认真阅读本协议。请您务必审慎阅读、充分理解各条款内容，特别是免除或者限制责任的条款、法律适用和争议解决条款。免除或者限制责任的条款将以粗体下划线标识，您应重点阅读。如您对协议有任何疑问，可向淘宝平台客服咨询。【签约动作】当您按照注册页面提示填写信息、阅读并同意本协议且完成全部注册程序后，即表示您已充分阅读、理解并接受本协议的全部内容，并与淘宝达成一致，成为淘宝平台“用户”。阅读本协议的过程中，如果您不同意本协议或其中任何条款约定，您应立即停止注册程序。&lt;/textarea&gt;&lt;br /&gt;&lt;input type=&quot;checkbox&quot; name=&quot;read&quot; value=&quot;&quot; /&gt;已阅读条款&lt;br /&gt;&lt;input type=&quot;reset&quot; value=&quot;重填&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交注册信息&quot; disabled=&quot;disabled&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="整活专题">整活专题</h3><p>这一部分里除了html和css还用到了一点简单的js，不要求完全理解，大概了解代码用途即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redux的原理、工作流程及其应用</title>
      <link href="/2023/05/21/%E5%88%86%E4%BA%AB/"/>
      <url>/2023/05/21/%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1>redux的原理、工作流程及其应用</h1><blockquote><p>Redux对于JavaScript应用而言是一个可预测状态的容器。换言之，它是一个应用数据流框架，而不是传统的像underscore.js或者AngularJs那样的库或者框架。</p></blockquote><h2 id="1、什么是redux？">1、什么是redux？</h2><p><strong>redux是专门用于集中式管理状态的javascript库</strong>，他并不是react的插件库。</p><p>比如你有多个组件A-E都想要用同一个组件D中的状态：<br>1）像以前我们可以通过父子组件通信的方式让父组件进行传递状态，或者是让兄弟组件之间通过<strong>订阅发布</strong>进行通信<br>2）当我们使用了<strong>redux</strong>就可以直接通过让redux进行统一的状态管理，谁想要用状态就自己去拿，<strong>省去</strong>了第一种方法的<strong>层层传递</strong></p><p><img src="https://s2.loli.net/2023/05/20/7tSbm6zQK51C4JB.jpg" alt="fa5eae9ac95848919417daff9ae5c20d.jpeg"></p><p><strong>2、redux的工作流程</strong></p><blockquote><p>在我们了解redux的工作流程之前我们应该要知道redux有三个核心概念，分别为actions、store、reducers（带s的表明可能存在多个）</p></blockquote><p><strong>1）actions</strong><br>actions英文直译过来就是行动、动作的意思，那么我们就可以猜到他表示的是“怎么做”，简单来说actions就是一个对象，actions里面有两个属性分别为<strong>type</strong>和<strong>data</strong>：<br>type：标识属性，值为字符串且唯一，必要属性（你想要做什么事情<br>data：数据属性，值为任意类型，可选属性（你要做事情的数据</p><p>那我们浅浅举个栗子：比如计算器你可以进行加1减2等操作，那么加减乘除这个操作就是你的type，数字就是你的数据</p><p><strong>2）store</strong><br>store有且只能有一个，他相当于一个最高指挥家，他负责把action动作交给对应的reducer进行执行，也就是说将state、action和reducer联系在一起的对象。</p><p><strong>3）reducer</strong><br>reducer用于将store发过来的action完成并将结果返回给store，他接收两个参数preState（旧状态）和action（动作）并返回一个newState（新状态）。</p><p>比如像计算器我们需要在原来的数据上进行加1的操作，那么旧状态旧对应原来的数据，action对应加1的操作，返回的新状态就是计算器加完之后重新返回的结果。</p><p><strong>那么他的工作流程是什么样的呢？</strong><br><img src="https://s2.loli.net/2023/05/20/T5i6vj7ar1nKPxC.png" alt="75e02503f8374e88a1678083336f0d71.png"><br>1）首先我们要确定我们要做什么<br>2）让Action Creators创建action（也就是你要做的事情）<br>3）通过dispatch将action分发出去<br>4）store对要使用的reducer进行绑定，然后将action分发到对应的reducer上<br>5）在reducer上进行相应的action操作并返回结果给store<br>6）组件就可以通过store的API像store进行获取操作返回的结果</p><h2 id="2-项目中使用Redux">2.项目中使用Redux</h2><p>这里就新建项目然后使用redux完成一个小案例</p><p>比如我们的微信和支付宝都绑定了同一张银行卡,当我们去使用支付宝或者微信支付的时候,对应的这个银行卡上的余额就会减少。也就是说支付宝和微信共享了银行卡的账户余额。</p><p>项目中要用到Redux，所以要先进行下载</p><pre><code>npm i -D redux</code></pre><p>我们来捋一捋实现这个功能的思路，在微信和支付宝端余额显示相同。思路是建立一个文件夹叫store，index.js中是我们用来创建store的,然后建立一个action来放咱们的一些action,我们通过action来修改store,连接action和store的是我们的reducer ,reducer是一个纯函数</p><p>store/index.js :</p><pre><code class="language-javascript">import &#123; legacy_createStore as createStore &#125; from 'redux'import reducer from './reducer'const store = createStore(reducer)export default store</code></pre><p>新建canstance.js文件，在里面定义对应的方法：</p><pre><code class="language-javascript">export const INCREMENT = 'INCREMENT'export const DECREMENT = 'DECREMENT'export const ADD_NUMBER = 'ADD_NUMBER'export const SUB_NUMBER = 'SUB_NUMBER'</code></pre><p>然后创建action的内容，新建action文件：</p><pre><code class="language-javascript">import &#123; INCREMENT, DECREMENT, ADD_NUMBER, SUB_NUMBER &#125; from './canstance'export const incAction = num =&gt;(&#123; type: INCREMENT, num &#125;)export const decAction = num =&gt;(&#123; type: DECREMENT, num &#125;)export const addAction = num =&gt;(&#123; type: ADD_NUMBER, num &#125;)export const subAction = num =&gt;(&#123; type: SUB_NUMBER, num &#125;)</code></pre><p>最后新建reducer文件，建立store和action之间的联系：</p><pre><code class="language-javascript">import &#123; INCREMENT, DECREMENT, ADD_NUMBER, SUB_NUMBER &#125; from './canstance'const initState = &#123;    money: 0&#125;const reducer = (state=initState, action) =&gt; &#123;    switch(action.type) &#123;        case INCREMENT:            return &#123;...state, money: state.money + 1&#125;        case DECREMENT:            return &#123;...state, money: state.money - 1&#125;        case ADD_NUMBER:            return &#123;...state, money: state.money + action.num&#125;        case SUB_NUMBER:            return &#123;...state, money: state.money - action.num&#125;        default:         return state    &#125;&#125;export default reducer</code></pre><p>最后来到开始创建的alipay.js和wxpay.js，这两个文件里面的内容大致相同，下面就举例说明一个<br>1.引入store.js<br>2.定义state状态，利用store .getState().money进行取值<br>3.在componentDidMount中进行值的更新</p><pre><code class="language-javascript">import React, &#123; PureComponent &#125; from 'react'import store from '../store'import &#123; addAction, subAction &#125; from '../store/action'export class Alipay extends PureComponent &#123;  state = &#123;    money: store.getState().money  &#125;  componentDidMount() &#123;    store.subscribe(() =&gt; &#123;      this.setState(&#123;money: store.getState().money&#125;)    &#125;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;支付宝&lt;/h1&gt;        &lt;h2&gt;余额：&#123;this.state.money&#125;&lt;/h2&gt;        &lt;button onClick=&#123;e =&gt; this.decrement(1)&#125;&gt;付钱&lt;/button&gt;        &lt;button onClick=&#123;e =&gt; this.makemoney(100)&#125;&gt;收钱&lt;/button&gt;      &lt;/div&gt;    )  &#125;  decrement(num) &#123;    store.dispatch(subAction(num))  &#125;  makemoney(num) &#123;    store.dispatch(addAction(num))  &#125;&#125;export default Alipay</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>promise</title>
      <link href="/2023/04/29/promise/"/>
      <url>/2023/04/29/promise/</url>
      
        <content type="html"><![CDATA[<h2 id="目录">目录</h2><p>-<a href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">异步编程</a><br>-<a href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">回调函数</a><br>-<a href="#%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1">回调地狱</a><br>-<a href="#promise">promise</a></p><h2 id="异步编程">异步编程</h2><p>js语言是<strong>单线程机制</strong>。所谓单线程就是按次序执行，执行完一个任务再执行下一个。但是不影响存在同步和异步的两种操作，这两种操作做事情其实都是在一条流水线上(单线程)，只是这两种操作在单线程上的执行顺序不一样罢了。当js触发到异步任务时，会将异步任务交给浏览器处理，当执行<strong>有结果</strong>时，会把异步任务的回调函数插入待处理队列的队尾。</p><p>通俗的去解释一下异步：异步就是从主线程发射一个子线程来完成任务，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的.</p><p><img src="https://s2.loli.net/2023/05/07/rsXiHucjDbzk5L1.png" alt="74d580d4b9924507b5148e6a8a6ae6ea.png"></p><h2 id="回调函数">回调函数</h2><p>回调函数的定义非常简单：一个函数被当做一个实参传入到另一个函数(外部函数)，并且这个函数在外部函数内被调用，用来完成某些任务的函数。就称为<strong>回调函数</strong><br>回调函数的两种写法(实现效果相同)：</p><pre><code class="language-javascript">const text = () =&gt; &#123;       document.write('hello james')&#125;setTimeout(text,1000)</code></pre><pre><code class="language-javascript">setTimeout(()=&gt;&#123;       document.write(&quot;hello james&quot;)&#125;,1000)</code></pre><p>这段代码中的 setTimeout 就是一个消耗时间较长的过程，它的第一个参数是个回调函数，第二个参数是毫秒数，这个函数执行之后会产生一个子线程，子线程会等待 1 秒，然后执行回调函数 “text”，在文本中输出hello james</p><p>setTimeout会在子线程中等待1秒，但是主线程的运行不会受到影响！例如以下代码：</p><pre><code class="language-javascript">setTimeout(()=&gt;&#123;    document.write(&quot;hello davis&quot;)&#125;,1000)console.log('123456');</code></pre><p>在这里会先打印出来123456(主线程),然后一秒后在文本中输出hello davis(子线程)</p><h2 id="回调地狱">回调地狱</h2><p>回调地狱这个词听起来就非常的高大上，想要接触Promise之前，必须要懂得什么是回调地狱，以及为什么会产生回调地狱？<br>先来看看概念：<strong>当一个回调函数嵌套一个回调函数的时候就会出现一个嵌套结构当嵌套的多了就会出现回调地狱的情况。</strong><br>举个例子：比如我们发送三个 ajax 请求：</p><p>第一个正常发送<br>第二个请求需要第一个请求的结果中的某一个值作为参数<br>第三个请求需要第二个请求的结果中的某一个值作为参数</p><p>你会看到以下代码：</p><pre><code class="language-javascript">$.ajax(&#123;  url: '我是第一个请求',  type: 'get',  success (res) &#123;    // 现在发送第二个请求    $.ajax(&#123;      url: '我是第二个请求'，      type:'post',      data: &#123; a: res.a, b: res.b &#125;,      success (res1) &#123;        // 进行第三个请求        $.ajax(&#123;          url: '我是第三个请求',          type:'post',          data: &#123; a: res1.a, b: res1.b &#125;,                  success (res2) &#123;             console.log(res2)           &#125;        &#125;)      &#125;    &#125;)  &#125;&#125;)</code></pre><p>当我们把代码写成这样的时候，就陷入了可维护性差的状态了，代码体验非常的不良好，为了解决这个问题，于是，就引入了Promise,用Promise去解决回调地狱问题</p><h2 id="promise">promise</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大,它是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。</p><p>Promise对象有以下两个特点:</p><p>1.<strong>对象的状态不受外界影响</strong>。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>2.<strong>一旦状态改变，就不会再变</strong>，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><h3 id="Promise语法格式">Promise语法格式</h3><pre><code class="language-javascript"> new Promise(function (resolve, reject) &#123;  // resolve 表示成功的回调  // reject 表示失败的回调&#125;).then(function (res) &#123;  // 成功的函数&#125;).catch(function (err) &#123;  // 失败的函数&#125;)</code></pre><p>出现了new关键字，就明白了Promise对象其实就是一个构造函数，是用来生成Promise实例的。能看出来构造函数接收了一个函数作为参数，该函数就是Promise构造函数的回调函数，该函数中有两个参数resolve和reject，这两个参数也分别是两个函数！</p><p>简单的去理解的话resolve函数的目的是将Promise对象状态变成成功状态，在异步操作成功时调用，将异步操作的结果，作为参数传递出去。reject函数的目的是将Promise对象的状态变成失败状态，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p><p>代码示例</p><pre><code class="language-javascript">      const promise = new Promise((resolve,reject)=&gt;&#123;          //异步代码          setTimeout(()=&gt;&#123;              // resolve(['111','222','333'])              reject('error')          &#125;,2000)      &#125;)      promise.then((res)=&gt;&#123;          //兑现承诺，这个函数被执行          console.log('success',res);      &#125;).catch((err)=&gt;&#123;          //拒绝承诺，这个函数就会被执行          console.log('fail',err);      &#125;)</code></pre><p><strong>代码分析</strong></p><p>上边说到Promise是一个构造函数，new之后等于说调用了构造函数，构造函数中传的参数是一个函数，这个函数内的两个参数分别又是两个函数(reslove和reject)，虽然感觉很绕，但是理清思路会很清晰的！我们得到对象promise,promise对象中自带有两个方法then和catch，这两个方法中会分别再传入一个回调函数，这个回调函数的目的在于返回你所需要成功或失败的信息！那么怎么去调用这两个回调函数呢？看下方图可以快速理解:</p><p><img src="https://s2.loli.net/2023/05/07/BQ5vlpLNKdT4Iob.png" alt="a4a0aebebaf54ba7a2b20305c4e0354a.png"></p><p>这两个函数分别作为参数(reslove和reject)传到上方的函数中去了.随后在构造函数的回调函数中写入异步代码(例如：ajax和定时器)，这里使用了定时器作为例子，如果你想表达的是成功回调，你可以在内部调用函数reslove('一般情况下是后端返回的成功数据)。如果你想表达的是失败回调，你可以调用reject(‘一般情况下是后端返回的失败信息’).</p><h3 id="Promise链式">Promise链式</h3><p>then方法返回的是一个新的Promise实例（注意:不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法实际案例：我想要实现在一个数组中查看一个帖子，但是我最终的目的是得到这个帖子下面的所有评论，这该怎么实现呢？</p><p>实现思路：</p><p>先从一个接口中获取这个帖子的信息，然后通过该帖子的帖子id从而获取到该帖子下的所有评论代码如下：</p><pre><code class="language-javascript">pajax(&#123;    url:&quot;http://localhost:3000/news&quot;,    data : &#123;        author : &quot;james&quot;    &#125;&#125;).then(res=&gt;&#123;    return pajax(&#123;        url : &quot;http://localhost:3000/comments&quot;,        data : &#123;            newsId : res[0].id        &#125;    &#125;)&#125;).then(res=&gt;&#123;    console.log(res);&#125;).catch(err=&gt;&#123;    console.log(err);&#125;)</code></pre><p><strong>代码分析：</strong></p><p>这里使用了一个Promise已经封装过的ajax，我们从第一个接口中得到了帖子id，然后在then中的函数发送第二个请求(携带了第一个请求返回过来的参数)，我们最后想要拿到第二个接口的结果，于是又有了一个then方法，但是在第一个then方法中要把一个新的Promise实例return出去，这样的话，第二个then才起作用！(这是因为then方法是Promise 实例所具有的方法，也就是说，then方法是定义在原型对象Promise.prototype上的)====&gt;我们可以打印一下：console.log(Promise.prototype)</p><h3 id="Promise-all">Promise.all()</h3><p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p>语法格式：</p><p>const p = Promise.all([p1, p2, p3]);</p><p>Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会调用Promise.reslove() [该方法可自行了解]自动将参数转为 Promise 实例，再进一步处理。说那么多白话没用，我们可以根据一个案例，就可以明白Promise.all()的用途了。实际案例：如果你想实现一个效果：在一个页面中，等到页面中所有的请求返回数据后，再渲染页面，该怎么实现呢？(在实际开发中我们会看到loading加载页面，等数据返回完后，loading加载页面会消失，整个页面就展现出来了，增强用户的体验。)<br>实现思路：通过Promise.all()方法，等多个接口全部接收到数据后，再统一进行处理，然后渲染页面代码如下：</p><pre><code class="language-javascript">console.log(&quot;显示加载中&quot;)const q1 = pajax(&#123;    url:&quot;http://localhost:3000/looplist&quot;&#125;)const q2 = pajax(&#123;    url:&quot;http://localhost:3000/datalist&quot;&#125;)Promise.all([q1,q2]).then(res=&gt;&#123;    console.log(res)    console.log(&quot;隐藏加载中...&quot;)&#125;).catch(err=&gt;&#123;    console.log(err)&#125;)</code></pre><p><strong>代码分析：</strong></p><p>在上方代码中，全局打印显示加载中是代替loading的页面，表示该页面现在正是loading页面中，等到q1和q2所请求接口都得到返回的信息后，在then方法中接收收据，并且可以进行渲染页面，同时隐藏了loading加载页面！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>词法作用域vs动态作用域</title>
      <link href="/2022/12/01/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9Fvs%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2022/12/01/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9Fvs%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1>词法作用域和动态作用域有什么不同？</h1><p>作用域分为 <strong>静态作用域</strong> 和 <strong>动态作用域</strong>，动态作用域在函数调用时才决定，而静态作用域在编译时期（词法解析阶段）就确定好了，所以也叫词法作用域。</p><pre><code>function fun() &#123;    console.log(a)&#125;function bar() &#123;    var a=3    fun()&#125;var a=1bar()  // 1</code></pre><p>在解释这个例子之前，还得讲解另一个知识点。</p><h2 id="LHS和RHS">LHS和RHS</h2><p>LSH(left-hand side)找到变量所在的容器本身，并且将对该变量进行赋值。</p><p>RHS(right-hand side)查找某个变量的值</p><p>LSH和RSH查找过程通过作用域链进行寻找。作用域链在函数定义的时候创建好。</p><p>现在说回这个例子，在fun函数要执行console.log(a)，就是要找到变量a的值，但是fun函数没有变量a，所以要通过RSH查询（当前作用域=&gt;上一级作用域=&gt; … =&gt; 全局作用域）找到变量a，在全局作用域里找到变量a，于是就输出1。</p><p>下面我们来看看动态作用域的例子（bash采用的是动态作用域)</p><pre><code>#!/bin/bashnum=1function fun1()&#123;    echo $num&#125;function fun2()&#123;    local num=2    fun1   // 2&#125;fun2</code></pre><p>动态作用域会从检查函数调用链，查找目标变量出来，所以就可以对上面的例子继续解释，在fun1函数找不到num变量，就会从调用栈中找到上一级调用fun1的函数fun2，并且在函数fun2找到变量num，所以就会输出2。</p><pre><code>function foo() &#123;    console.log(a);&#125;function bar() &#123;    var a = 3;    foo();&#125;var a = 2;bar(); // 2;</code></pre><p>这个js程序使用的是词法作用域。如果它使用动态作用域，将会输出什么？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>What is Closure?</title>
      <link href="/2022/12/01/closure/"/>
      <url>/2022/12/01/closure/</url>
      
        <content type="html"><![CDATA[<h1>闭包是什么？</h1><p>在了解闭包之前，我们要先理解JavaScript的作用域——全局作用域和局部作用域（先不考虑块级作用域）。</p><ul class="lvl-0"><li class="lvl-2"><p>在全局作用域下声明的变量就是全局变量.</p></li><li class="lvl-2"><p>在局部作用域下声明的变量就是局部变量。</p></li></ul><p>因为 <strong>作用域</strong> 链的存在，函数内部可以直接读取全局变量。而函数内部无法读取函数内部的局部变量。</p><p><strong>作用域链是什么？</strong></p><blockquote><p>当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。</p></blockquote><p><strong>闭包的概念</strong></p><blockquote><p>闭包就是在一个函数内部创建另一个函数，让你可以在一个内层函数中访问到其外层函数的作用域。又或者说，闭包就是能够读取其他函数内部变量的函数。</p></blockquote><pre><code>function wrapValue(n) &#123;let local = n;return () =&gt; local; //内层匿名函数访问外层函数变量n&#125;let wrap1 = wrapValue(1);let wrap2 = wrapValue(2);console.log(wrap1());// → 1console.log(wrap2());// → 2</code></pre><p>这个例子来自于《JavaScript编程精解》，其中给wrap1赋值为一个包含 1 的一个函数此时我们使用求值结果运算符来访问这个函数，函数返回了1，所以我们看到了1</p><p>wrap2 同理</p><pre><code>function multiplier(factor) &#123;return number =&gt; number * factor;&#125;let twice = multiplier(2);console.log(twice(5));// → 10</code></pre><h1>闭包的作用是什么？</h1><p>闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。</p><p>假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。</p><p>如果不用闭包，你可以直接用一个全局变量：</p><pre><code>window.lives = 30 // 还有三十条命</code></pre><p>这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？</p><p>用局部变量。</p><p>但是用局部变量别人又访问不到，怎么办呢？</p><p>暴露一个访问器（函数），让别人可以「间接访问」。</p><p>代码如下：</p><pre><code>!function()&#123;var lives = 50window.奖励一条命 = function()&#123;    lives += 1&#125;window.死一条命 = function()&#123;    lives -= 1&#125;&#125;()</code></pre><p>这就是闭包的第一个优点：<strong>保证函数不受外界干扰，实现封装，避免命名冲突</strong></p><pre><code>function f1()&#123;    var n=2;    function f2()&#123;        var q=0;        console.log('n=',++n);        console.log('q=',++q);    &#125;    return  f2;&#125;var f=f1();f() f() //这两个f(n)的结果分别是什么？？</code></pre><p>在上面这个例子中， f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，所以f2 始终在内存中，且 f2 的存在依赖于 f1中的n，这就导致变量n无法被销毁，而变量q是每次被调用时新创建的，所以每次f2执行完后它就把属于自己的变量连同自己一起销毁，于是乎最后就剩下孤零零的n。</p><p>这就是闭包的第二个优点： <strong>可以在内存中保存函数变量，不会被垃圾回收机制回收，充当缓存</strong></p><p>但闭包也有缺点： <strong>内存消耗很大，容易造成内存泄漏, 要谨慎使用</strong></p><blockquote><p>内存泄漏：内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p></blockquote><p>闭包的作用就是可以在一个函数的内部访问到函数外部的变量。这是因为内部函数对外部函数属于同一作用域内，通过闭包内的函数访问到变量是因为内部函数保持着对变量的 <strong>引用</strong>，当注册一个点击事件的时候，就是一个闭包，当点击事件完成的时候，还会对改变量保持着引用。</p><p>让我们再看看上面的例子,我们已经无法再通过js代码来引用到变量n，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它。导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。</p><blockquote><p>其实内存泄漏并不是闭包造成的，而是通过闭包内的函数对变量的引用，闭包不是真正产生内存泄漏的原因！大量博客记录的实际遇到的闭包产生内存泄漏问题的根本原因就是没有及时的断开对变量的引用，而不是注册监听事件的闭包产生的内存泄漏。如果我们对该引用可以进行控制，就可以解决内存泄漏的问题，而不应该把这个锅甩给无辜的闭包。</p></blockquote><p>解决方法：可以在后面加一句</p><pre><code>f=null</code></pre><p>这样就销毁了其返回函数，也就解除了对不能释放的活动对象n的引用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>react源码分析之hooks</title>
      <link href="/2022/11/26/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bhooks/"/>
      <url>/2022/11/26/react%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bhooks/</url>
      
        <content type="html"><![CDATA[<h2 id="Hook"><strong>Hook</strong></h2><p>每一个 hooks 方法都会生成一个类型为 Hook 的对象，用来存储一些信息，前面提到过函数组件 fiber 中的 memoizedState 会存储 hooks 链表，每个链表结点的结构就是 Hook。</p><pre><code class="language-javascript">// packages/react-reconciler/src/ReactFiberHooks.old.jsexport type Hook = &#123;|  memoizedState: any, // 上次渲染时所用的 state  baseState: any, // 已处理的 update 计算出的 state  baseQueue: Update&lt;any, any&gt; | null, // 未处理的 update 队列（一般是上一轮渲染未完成的 update）  queue: UpdateQueue&lt;any, any&gt; | null, // 当前出发的 update 队列  next: Hook | null, // 指向下一个 hook，形成链表结构|&#125;;</code></pre><p>举个例子，我们通过函数组件使用了两个 <code>useState</code> hooks：</p><pre><code class="language-javascript">const [name, setName] = useState('ggb');const [age, setAge] = useState(23);</code></pre><p>则实际的 Hook 结构如下：</p><pre><code class="language-javascript">&#123;  memoizedState: 'ggb',  baseState: 'ggb',  baseQueue: null,  queue: null,  next: &#123;    memoizedState: 23,    baseState: 23,    baseQueue: null,    queue: null,  &#125;,&#125;;</code></pre><p>不同的 hooks 方法，memoizedState 存储的内容不同，常用的 hooks memoizedState 存储的内容如下：</p><ul class="lvl-0"><li class="lvl-2"><p>useState: state</p></li><li class="lvl-2"><p>useEffect: effect 对象</p></li><li class="lvl-2"><p>useMemo/useCallback: [callback, deps]</p></li><li class="lvl-2"><p>useRef: { current: xxx }</p></li></ul><p><strong>Update &amp; UpdateQueue</strong><br>Update 和 UpdateQueue 是存储 <code>useState</code> 的 state 及<code>useReducer </code>的 reducer 相关内容的数据结构。</p><pre><code class="language-javascript">// packages/react-reconciler/src/ReactFiberHooks.old.jstype Update&lt;S, A&gt; = &#123;|  lane: Lane, // 优先级  // reducer 对应要执行的 action  action: A,  // 触发 dispatch 时的 reducer  eagerReducer: ((S, A) =&gt; S) | null,  // 触发 dispatch 是的 state  eagerState: S | null,  // 下一个要执行的 Update  next: Update&lt;S, A&gt;,  // react 的优先级权重  priority?: ReactPriorityLevel,|&#125;;type UpdateQueue&lt;S, A&gt; = &#123;|  // 当前要触发的 update  pending: Update&lt;S, A&gt; | null,  // 存放 dispatchAction.bind() 的值  dispatch: (A =&gt; mixed) | null,  // 上一次 render 的 reducer  lastRenderedReducer: ((S, A) =&gt; S) | null,  // 上一次 render 的 state  lastRenderedState: S | null,|&#125;;</code></pre><p>每次调用 <code>setState </code>或者 <code>useReducer</code> 的 dispatch 时，都会生成一个 Update 类型的对象，并将其添加到 UpdateQueue 队列中。</p><p>例如，在如下的函数组件中:</p><pre><code class="language-javascript">const [name, setName] = useState('ggb');setName('猪猪侠');</code></pre><p>当我们点击 input 按钮时，执行了 <code>setName()</code>，此时对应的 hook 结构如下：</p><pre><code class="language-javascript">&#123;  memoizedState: 'ggb',  baseState: 'ggb',  baseQueue: null,  queue: &#123;    pending: &#123;      lane: 1,      action: '猪猪侠',      eagerState: '猪猪侠',      // ...    &#125;,    lastRenderedState: 'ggb',    // ...  &#125;,  next: null,&#125;;</code></pre><p>最后 react 会遍历 UpdateQueue 中的每个 Update 去进行更新。</p><p><strong>Effect</strong><br>Effect 结构是和 <code>useEffect</code> 等 hooks 相关的，我们看一下它的结构：</p><pre><code class="language-javascript">// packages/react-reconciler/src/ReactFiberHooks.old.jsexport type Effect = &#123;|  tag: HookFlags, // 标记是否有 effect 需要执行  create: () =&gt; (() =&gt; void) | void, // 回调函数  destroy: (() =&gt; void) | void, // 销毁时触发的回调  deps: Array&lt;mixed&gt; | null, // 依赖的数组  next: Effect, // 下一个要执行的 Effect|&#125;;</code></pre><p>当我们的函数组件中使用了如下的<code>useEffect</code>时：</p><pre><code class="language-javascript">useEffect(() =&gt; &#123;  console.log('hello');  return () =&gt; &#123;    console.log('bye');  &#125;;&#125;, []);</code></pre><p>对应的 Hook 如下：</p><pre><code class="language-javascript">&#123;  memoizedState: &#123;    create: () =&gt; &#123; console.log('hello') &#125;,    destroy: () =&gt; &#123; console.log('bye') &#125;,    deps: [],    // ...  &#125;,  baseState: null,  baseQueue: null,  queue: null,  next: null,&#125;</code></pre><h3 id="执行过程">执行过程</h3><p>下面我们探索一下 hooks 在 react 中具体的执行流程。</p><h4 id="引入-hooks">引入 hooks</h4><p>我们以一个简单的 hooks 写法的 react 应用程序为例去寻找 hooks 源码:</p><pre><code class="language-jsx">import &#123; useState &#125; from 'react';export default function App() &#123;  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;&#123;count&#125;&lt;/p&gt;      &lt;input        type=&quot;button&quot;        value=&quot;增加&quot;        onClick=&#123;() =&gt; &#123;          setCount(count + 1);        &#125;&#125;      /&gt;    &lt;/div&gt;  );&#125;</code></pre><p>根据引入的 <code>useState</code> api，我们找到 react hooks 的入口文件：</p><pre><code class="language-jsx">// packages/react/src/ReactHooks.jsfunction resolveDispatcher() &#123;  const dispatcher = ReactCurrentDispatcher.current;  // ...  return dispatcher;&#125;export function useState&lt;S&gt;(  initialState: (() =&gt; S) | S,): [S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt;] &#123;  const dispatcher = resolveDispatcher();  return dispatcher.useState(initialState);&#125;// ...</code></pre><p>根据上面的源码我们可以知道，所有的 hooks api 都是挂载在<code> resolveDispatcher</code> 中返回的 dispatcher 对象上面的，也就是挂载在 <code>ReactCurrentDispatcher.current</code> 上面，那么我们再继续去看一下 <code>ReactCurrentDispatcher</code> 是什么：</p><pre><code class="language-javascript">// packages/react/src/ReactCurrentDispatcher.jsimport type &#123;Dispatcher&#125; from 'react-reconciler/src/ReactInternalTypes';const ReactCurrentDispatcher = &#123;  current: (null: null | Dispatcher),&#125;;export default ReactCurrentDispatcher;</code></pre><p>到这里我们的线索就断了，<code>ReactCurrentDispatcher</code> 上只有一个 current 用于挂在 hooks，但是 hooks 的详细源码以及 <code>ReactCurrentDispatcher </code>的具体内容我们并没有找到在哪里，所以我们只能另寻出路，从 react 的执行过程去入手。</p><p><strong>函数组件更新过程</strong></p><p>我们的 hooks 都是在函数组件中使用的，所以让我们去看一下 render 过程关于函数组件的更新。render 过程中的调度是从<code>beginWork</code>开始的，来到 <code>beginWork</code> 的源码后我们可以发现，针对函数组件的渲染和更新，使用了 <code>updateFunctionComponent </code>函数：</p><pre><code class="language-javascript">// packages/react-reconciler/src/ReactFiberBeginWork.old.jsfunction beginWork(  current: Fiber | null,  workInProgress: Fiber,  renderLanes: Lanes,): Fiber | null &#123;  // ...  switch (workInProgress.tag) &#123;    // ...    case FunctionComponent: &#123;      // ...      return updateFunctionComponent(        current,        workInProgress,        Component,        resolvedProps,        renderLanes,      );    &#125;    // ...  &#125;  // ...&#125;</code></pre><p>那我们在继续看一下 <code>updateFunctionComponent</code> 函数的源码，里面调用了 <code>renderWithHooks</code> 函数，这便是函数组件更新和渲染过程执行的入口：</p><pre><code class="language-javascript">// packages/react-reconciler/src/ReactFiberBeginWork.old.jsfunction updateFunctionComponent(  current,  workInProgress,  Component,  nextProps: any,  renderLanes,) &#123;  // ...  nextChildren = renderWithHooks(      current,      workInProgress,      Component,      nextProps,      context,      renderLanes,    );  // ...&#125;</code></pre><h4 id="renderWithHooks">renderWithHooks</h4><p>费劲千辛万苦，我们终于来到了函数组件更新过程的执行入口 —— <code>renderWithHooks</code> 函数的源码：</p><pre><code class="language-javascript">// packages/react-reconciler/src/ReactFiberBeginWork.old.jsexport function renderWithHooks&lt;Props, SecondArg&gt;(  current: Fiber | null,  workInProgress: Fiber,  Component: (p: Props, arg: SecondArg) =&gt; any,  props: Props,  secondArg: SecondArg,  nextRenderLanes: Lanes,): any &#123;  renderLanes = nextRenderLanes;  // currentlyRenderingFiber 指向当前所执行的fiber  currentlyRenderingFiber = workInProgress;  // 置空 workInProgress fiber 中的 memoizedState 和 updateQueue  workInProgress.memoizedState = null;  workInProgress.updateQueue = null;  workInProgress.lanes = NoLanes;  // ...  // 根据是否首次渲染，分别将 HooksDispatcherOnMount 和 HooksDispatcherOnUpdate 赋值给 ReactCurrentDispatcher.current  ReactCurrentDispatcher.current =      current === null || current.memoizedState === null        ? HooksDispatcherOnMount        : HooksDispatcherOnUpdate;  // 执行函数组件的构造函数  let children = Component(props, secondArg);  if (didScheduleRenderPhaseUpdateDuringThisPass) &#123;    // didScheduleRenderPhaseUpdateDuringThisPass 为 true 说明发生了 re-render，会再次执行 render    let numberOfReRenders: number = 0;    do &#123;      didScheduleRenderPhaseUpdateDuringThisPass = false;      // ...      ReactCurrentDispatcher.current = __DEV__        ? HooksDispatcherOnRerenderInDEV        : HooksDispatcherOnRerender;      children = Component(props, secondArg);    &#125; while (didScheduleRenderPhaseUpdateDuringThisPass);  &#125;  // ...  // 函数执行结束后，关闭 hooks 入口  ReactCurrentDispatcher.current = ContextOnlyDispatcher;  // ...当前 fiber 的任务执行结束，重置全局变量  renderLanes = NoLanes;  currentlyRenderingFiber = (null: any);  currentHook = null;  workInProgressHook = null;  didScheduleRenderPhaseUpdate = false;  // ...  return children;&#125;</code></pre><p><code>renderWithHooks</code> 函数中首先会将 workInProgress fiber 树的 memoizedState（memoizedState 记录了当前页面的 state，在函数组件中，它以链表的形式记录了 hooks 信息） 和 updateQueue 置为 null，在接下来的函数组件执行过程中，会把新的 hooks 信息挂载到这两个属性上，然后在 commit 阶段，会将根据 current fiber 树构建当前的 workInProgress fiber 树，并保存 hooks 信息，用于替换真实的 DOM 元素节点。</p><p>然后会通过 current 上是否有 memoizedState，判断组件是否首次渲染，从而分别将 HooksDispatcherOnMount 和 HooksDispatcherOnUpdate 赋值给<code> ReactCurrentDispatcher.current</code>。</p><p>接下来执行 <code>Component() </code>来调用函数组件的构造函数，组件的 hooks 会被依次执行，并将 hooks 的信息保存到 workInProgress fiber 上（待会儿会细讲执行过程），然后将返回的 jsx 信息保存到 children 上。</p><p>最后会重置一些变量，并返回函数组件执行后的 jsx。</p><p><strong>不同阶段更新Hook</strong><br>现在我们终于找到了 ReactCurrentDispatcher.current 的定义，首次渲染时，会将 HooksDispatcherOnMount 赋值给 ReactCurrentDispatcher.current，更新时，会将 HooksDispatcherOnUpdate 赋值给 ReactCurrentDispatcher.current， dispatcher 上面挂在了各种 hooks：// packages/react-reconciler/src/ReactFiberHooks.old.js</p><pre><code class="language-javascript">const HooksDispatcherOnMount: Dispatcher = &#123;  readContext,  useCallback: mountCallback,  useContext: readContext,  useEffect: mountEffect,  useImperativeHandle: mountImperativeHandle,  useLayoutEffect: mountLayoutEffect,  useMemo: mountMemo,  useReducer: mountReducer,  useRef: mountRef,  useState: mountState,  useDebugValue: mountDebugValue,  useDeferredValue: mountDeferredValue,  useTransition: mountTransition,  useMutableSource: mountMutableSource,  useOpaqueIdentifier: mountOpaqueIdentifier,  unstable_isNewReconciler: enableNewReconciler,&#125;;const HooksDispatcherOnUpdate: Dispatcher = &#123;  readContext,  useCallback: updateCallback,  useContext: readContext,  useEffect: updateEffect,  useImperativeHandle: updateImperativeHandle,  useLayoutEffect: updateLayoutEffect,  useMemo: updateMemo,  useReducer: updateReducer,  useRef: updateRef,  useState: updateState,  useDebugValue: updateDebugValue,  useDeferredValue: updateDeferredValue,  useTransition: updateTransition,  useMutableSource: updateMutableSource,  useOpaqueIdentifier: updateOpaqueIdentifier,  unstable_isNewReconciler: enableNewReconciler,&#125;;</code></pre><p>首次渲染时，<code>HooksDispatcherOnMount </code>上挂载的 hook 都是 mountXXX，而更新时 <code>HooksDispatcherOnMount </code>上挂在的 hook 都是 updateXXX。所有 mount 阶段的 hook 中，都会执行<code> mountWorkInProgressHook</code> 这个函数，而所有 update 阶段的 hook 中，都会执行<code>updateWorkInProgressHook</code> 这个函数。下面我们来看下这两个函数分别做了什么。</p><p><strong>mountWorkInProgressHook</strong><br>每个 hooks 方法中，都需要有一个 Hook 结构来存储相关信息。<code>mountWorkInProgressHook</code> 中，会初始化创建一个 Hook，然后将其挂载到 workInProgress fiber 的 memoizedState 所指向的 hooks 链表上，以便于下次 update 的时候取出该 Hook：</p><pre><code class="language-javascript">// packages/react-reconciler/src/ReactFiberHooks.old.jsfunction mountWorkInProgressHook(): Hook &#123;  const hook: Hook = &#123;    memoizedState: null,    baseState: null,    baseQueue: null,    queue: null,        next: null,  &#125;;  if (workInProgressHook === null) &#123;    // 若当前 workInProgressHook 为 null，将此 hook 作为 memoizedState 的头结点    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;  &#125; else &#123;    // 若不为 null，将 hook 挂载到链表最后    workInProgressHook = workInProgressHook.next = hook;  &#125;  return workInProgressHook;&#125;</code></pre><h5 id="updateWorkInProgressHook">updateWorkInProgressHook</h5><p><code>updateWorkInProgressHook</code> 的作用主要是取出 current fiber 中的 hooks 链表中对应的 hook 节点，挂载到 workInProgress fiber 上的 hooks 链表：</p><pre><code class="language-js">// packages/react-reconciler/src/ReactFiberHooks.old.jsfunction updateWorkInProgressHook(): Hook &#123;  let nextCurrentHook: null | Hook;  // 迭代 current fiber 链表  if (currentHook === null) &#123;    // 若 current 为 null，从 currentlyRenderingFiber.alternate 取 current    const current = currentlyRenderingFiber.alternate;    if (current !== null) &#123;      nextCurrentHook = current.memoizedState;    &#125; else &#123;      nextCurrentHook = null;    &#125;  &#125; else &#123;    // 否则从 current fiber 中取下一个 hook    nextCurrentHook = currentHook.next;  &#125;  // 迭代 workInProgress fiber 链表  let nextWorkInProgressHook: null | Hook;  if (workInProgressHook === null) &#123;    // workInProgressHook 说明是首次创建    nextWorkInProgressHook 为 null = currentlyRenderingFiber.memoizedState;  &#125; else &#123;    // 取下一个 workInProgress Hook    nextWorkInProgressHook = workInProgressHook.next;  &#125;  if (nextWorkInProgressHook !== null) &#123;    // 只有 re-render 的情况下，nextWorkInProgressHook 不为 null，因为在之前的 render 过程中已经创建过 workInProgress hook了    // 此时复用    workInProgressHook = nextWorkInProgressHook;    nextWorkInProgressHook = workInProgressHook.next;    currentHook = nextCurrentHook;  &#125; else &#123;    // 正常情况下，currentlyRenderingFiber.memoizedState 为 null，需要到从 current fiber 中克隆一个新的创建    invariant(      nextCurrentHook !== null,      'Rendered more hooks than during the previous render.',    );    currentHook = nextCurrentHook;        const newHook: Hook = &#123;      memoizedState: currentHook.memoizedState,          baseState: currentHook.baseState,      baseQueue: currentHook.baseQueue,      queue: currentHook.queue,          next: null,    &#125;;        if (workInProgressHook === null) &#123;      // 若 workInProgressHook 为 null，作为首节点赋值给 memoizedState      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;    &#125; else &#123;      // 将 workInProgressHook 添加到链表尾      workInProgressHook = workInProgressHook.next = newHook;    &#125;    &#125;  return workInProgressHook;&#125;</code></pre><p>我们详细理解一下上述代码，前面我们提到过 <code>renderWithHooks </code>函数中会执行如下代码：<code> workInProgress.memoizedState = null</code>，所以在执行上述函数时，正常来说 <code>currentlyRenderingFiber.memoizedState</code> 为 null，需要从 current fiber 对应的节点中取 clone 对应的 hook，再挂载到 workInProgress fiber 的 memoizedState 链表上；re-render 的情况下，由于已经创建过了 hooks，会复用已有的 workInProgress fiber 的 memoizedState。</p><p>这里正好提到，为什么 hook 不能用在条件语句中，因为如果前后两次渲染的条件判断不一致时，会导致 current fiber 和 workInProgress fiber 的 hooks 链表结点无法对齐。</p><p><strong>总结</strong><br>所以我们总结一下 <code>renderWithHooks </code>这个函数，它所做的事情如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/60d6d79cf73ada152caa514b442bc6e2.webp?x-oss-process=image/format,png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first blog</title>
      <link href="/2022/11/18/my-first-blog/"/>
      <url>/2022/11/18/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>我的第一篇博客！！</p>]]></content>
      
      
      <categories>
          
          <category> amiii </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/18/hello-world/"/>
      <url>/2022/11/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><pre><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
