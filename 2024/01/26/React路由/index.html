<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>React路由</title><meta name="description" content="逆风如解意，容易莫摧残"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="React路由介绍
现代的前端应用大多都是 SPA（单页应用程序）single page application，也就是只有一个 HTML 页面的应用程序。因为它的用户体验更好、对服务器的压力更小，所以更受欢迎。
为了有效的使用单个页面来管理原来多页面的功能，前端路由应运而生。

前端路由的功能：让用户从一个视图（页面）导航到另一个视图（页面）



前端路由是一套映射规则，在React中，是 URL路径 与 组件 的对应关系 。一个路由就是一对映射关系–&amp;gt;key：value


使用React路由简单来说，就是配置 路径和组件（配对）


前后端路由介绍


后端路由：
1)理解： value是function, 用来处理客户端提交的请求。
2)注册路由： router.get(path, func.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">ami's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">React路由</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#React%E8%B7%AF%E7%94%B1%E4%BB%8B%E7%BB%8D"><span class="toc-text">React路由介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">React 路由的基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">路由的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA"><span class="toc-text">编程式导航</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">实现步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-text">路由传参(函数式组件的路由传参)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-searchParams%E4%BC%A0%E5%8F%82"><span class="toc-text">1. searchParams传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-params%E4%BC%A0%E5%8F%82"><span class="toc-text">2.params传参</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#404%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE"><span class="toc-text">404路由配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">实现步骤:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="toc-text">示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redirect-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">Redirect (重定向)</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/React"><i class="tag post-item-tag">React</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">React路由</h1><time class="has-text-grey" datetime="2024-01-25T16:00:00.000Z">2024-01-26</time><article class="mt-2 post-content"><h2 id="React路由介绍">React路由介绍</h2>
<p>现代的前端应用大多都是 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=SPA&amp;spm=1001.2101.3001.7020">SPA</a>（单页应用程序）single page application，也就是只有一个 HTML 页面的应用程序。因为它的用户体验更好、对服务器的压力更小，所以更受欢迎。</p>
<p>为了有效的使用单个页面来管理原来多页面的功能，前端路由应运而生。</p>
<blockquote>
<p>前端路由的功能：让用户<strong>从一个视图（页面）导航到另一个视图（页面）</strong></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>前端路由是一套映射规则，在React中，是 URL路径 与 组件 的对应关系 。一个路由就是一对映射关系–&gt;key：value</p>
</li>
<li class="lvl-2">
<p>使用React路由简单来说，就是配置 路径和组件（配对）</p>
</li>
</ul>
<p><strong>前后端路由介绍</strong></p>
<ol>
<li class="lvl-3">
<p>后端路由：<br>
1)理解： value是function, 用来处理客户端提交的请求。<br>
2)注册路由： router.get(path, function(req, res))<br>
3)工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</p>
</li>
<li class="lvl-3">
<p>前端路由：<br>
1)浏览器端路由，value是component，用于展示页面内容。<br>
2)注册路由: <Route path="/test" component={Test}><br>
3)工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</p>
</li>
</ol>
<p><strong>路由的本质:</strong> 一个路径 path 对应唯一的一个组件 component 当我们访问一个 path 自动把 path 对应的组件进行渲染。</p>
<h2 id="React-路由的基本使用">React 路由的基本使用</h2>
<p><strong>1. 安装</strong></p>
<p>首先你要有一个React项目：（这是 React 脚手架初始化项目）</p>
<pre><code>npx create-react-app my-app
</code></pre>
<p>注：<strong>React 路由使用前需要*<em>先安装 react-router-dom 的包*</em></strong>，React <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%84%9A%E6%89%8B%E6%9E%B6&amp;spm=1001.2101.3001.7020">脚手架</a>初始化项目时不会自动安装这个包，需要我们手动再安装</p>
<p><strong>安装包</strong>：<code>yarn add react-router-dom</code> 或 <code>npm i react-router-dom@6</code></p>
<p><strong>2.React路由demo</strong></p>
<p>代码示例：</p>
<pre><code class="language-javascript">import &#123; BrowserRouter, Routes, Route, Link &#125; from 'react-router-dom'
 
function Home () &#123;
  return (
    &lt;p&gt;这是首页的内容&lt;/p&gt;
  )
&#125;
function About () &#123;
  return (
    &lt;p&gt;这是关于的内容&lt;/p&gt;
  )
&#125;
function App () &#123;
  return (
    // 声明当前要用一个非hash模式的路由
    &lt;BrowserRouter&gt;
      &lt;div className=&quot;App&quot;&gt;
        &#123;/* 指定跳转的组件，to 用来配置路由地址 */&#125;
        &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;br /&gt;
        &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;
        &#123;/* 路由出口：路由对应的组件会在这里进行渲染 */&#125;
        &lt;Routes&gt;
          &#123;/* 指定路由路径和组件的对应关系：path 代表路径，element 代表对应的组件，它们成对出现 */&#125;
          &lt;Route path='/' element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
          &lt;Route path='/about' element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;
        &lt;/Routes&gt;
      &lt;/div&gt;
    &lt;/BrowserRouter&gt;
  )
&#125;
 
export default App
</code></pre>
<p><strong>3.总结</strong></p>
<p>两种常用的路由模式：BrowserRouter和HashRouter</p>
<table>
<thead>
<tr>
<th>核心组件</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>BrowserRouter</td>
<td>声明当前要用一个非hash的模式的路由包裹整个应用。一个React应用只需使用一次。使用 H5 的 history.pushState API 实现（<a target="_blank" rel="noopener" href="http://localhost:3000/first%EF%BC%89%EF%BC%88**%E6%8E%A8%E8%8D%90**%EF%BC%89">http://localhost:3000/first）（**推荐**）</a></td>
</tr>
<tr>
<td>HashRouter</td>
<td>hash模式的路由。一个有#（HashRouter），一个不带#（BrowserRouter）                                                          使用 URL 的哈希值实现（<a target="_blank" rel="noopener" href="http://localhost:3000/#/first%EF%BC%89">http://localhost:3000/#/first）</a></td>
</tr>
<tr>
<td>Link</td>
<td>指定导航链接，完成路由跳转。to属性指定路由地址，最终被渲染为a标签</td>
</tr>
<tr>
<td>Routes</td>
<td>提供一个路由出口，满足条件的路由组件，会渲染到组件内部</td>
</tr>
<tr>
<td>Route</td>
<td>用于指定路由组件和路由地址。path：路由组件对应的路径；element：路由组件；<strong>成对出现</strong></td>
</tr>
</tbody>
</table>
<h2 id="路由的执行过程">路由的执行过程</h2>
<ol>
<li class="lvl-3">
<p>点击 Link 组件（a标签），修改了浏览器地址栏中的 url 。</p>
</li>
<li class="lvl-3">
<p>React 路由监听到地址栏 url 的变化。</p>
</li>
<li class="lvl-3">
<p>React 路由内部遍历所有 Route 组件，使用路由规则（ path ）与 pathname 进行匹配。</p>
</li>
<li class="lvl-3">
<p>当路由规则（path）能够匹配地址栏中的 pathname 时，就展示该 Route 组件的内容。、</p>
</li>
</ol>
<h2 id="编程式导航">编程式导航</h2>
<p>注：上面使用 <Link to="/">跳转</Link> 的方式是：<strong>声明式导航</strong></p>
<p><strong>编程式导航</strong>: 通过 <strong>js 编程的方式进行路由页面跳转</strong>，比如说从首页跳转到关于页</p>
<h4 id="实现步骤："><strong>实现步骤</strong>：</h4>
<ol>
<li class="lvl-3">
<p>导入一个 useNavigate 钩子函数</p>
</li>
<li class="lvl-3">
<p>执行 useNavigate 函数 得到 跳转函数</p>
</li>
<li class="lvl-3">
<p>在事件中执行跳转函数完成路由跳转</p>
</li>
</ol>
<h4 id="示例代码">示例代码</h4>
<pre><code class="language-javascript">// 导入useNavigate函数
import &#123; useNavigate &#125; from 'react-router-dom'
const Home = () =&gt; &#123;
  // 执行函数
  const navigate = useNavigate()
  return (
    &lt;div&gt;
      Home
      &lt;button onClick=&#123; ()=&gt; navigate('/about') &#125;&gt; 跳转关于页 &lt;/button&gt;
    &lt;/div&gt;
  )
&#125;
 
export default Home
</code></pre>
<p>注: 如果在跳转时不<strong>想添加历史记录</strong>，可以添加额外参数 <strong>replace 为 true</strong></p>
<pre><code class="language-javascript">navigate('/about', &#123; replace: true &#125; )
</code></pre>
<h2 id="路由传参-函数式组件的路由传参">路由传参(函数式组件的路由传参)</h2>
<p>跳转路由的同时，很多时候都需要传递参数，这里有两种传参方式：</p>
<h4 id="1-searchParams传参">1. searchParams传参</h4>
<p><strong>路由传参</strong></p>
<pre><code class="language-javascript"> navigate('/?id=1001&amp;name=zs', &#123; replace: true &#125;)
</code></pre>
<p><strong>路由取参</strong></p>
<pre><code class="language-javascript">import &#123; useSearchParams &#125; from 'react-router-dom'
// 在Home中读取页面传递过来的参数(以路径拼接的方式传递过来的参数)
function Home () &#123;
  const [params] = useSearchParams()
  // params 是一个对象，对象里有一个get方法用来获取对应的参数
  // 把参数的名称作为get方法的实参传递即可
  const id = params.get('id')
  const name = params.get('name')
  return (
    &lt;p&gt;这是首页的内容,首页获取到的参数id:&#123;id&#125;,name:&#123;name&#125;&lt;/p&gt;
  )
&#125;
</code></pre>
<h4 id="2-params传参">2.params传参</h4>
<p><strong>路由传参</strong></p>
<pre><code class="language-javascript">    navigate('/about/1002/lisi', &#123; replace: true &#125;)
</code></pre>
<p><strong>设置参数占位符</strong></p>
<pre><code class="language-javascript">&#123;/* 使用 params 传参和接收参数时，指定路由路径时需要提前使用“占位符”给参数进行占位 */&#125;
&lt;Route path='/about/:id/:name' element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;
</code></pre>
<p><strong>路由取参</strong></p>
<pre><code class="language-javascript">import &#123; useParams &#125; from 'react-router-dom'
// 在关于页面接收登录页使用 params 传参的方式传递过来的参数
function About () &#123;
  const params = useParams()
  return (
    &lt;p&gt;这是关于的内容,接收到登录页传递过来的id为：&#123;params.id&#125;,name为&#123;params.name&#125;&lt;/p&gt;
  )
&#125;
</code></pre>
<h2 id="404路由配置">404路由配置</h2>
<p>场景：当 url 的路径在整个路由配置中都找不到对应的 path ，使用404兜底组件进行渲染。</p>
<h4 id="实现步骤"><strong>实现步骤:</strong></h4>
<ol>
<li class="lvl-3">
<p>准备一个 NotFound 组件（404的页面）</p>
</li>
<li class="lvl-3">
<p>把该组件的路由对应关系配置为 <strong>Routes 内部的一级路由，path=‘*’</strong></p>
</li>
</ol>
<h4 id="示例代码-2"><strong>示例代码</strong></h4>
<pre><code class="language-javascript">import &#123; BrowserRouter, Routes, Route &#125; from 'react-router-dom'
 
// 定义 404 组件
const NotFound = () =&gt; &#123;
  return (
    &lt;h1&gt;404  抱歉,页面未找到TAT&lt;/h1&gt;
  )
&#125;
function App () &#123;
  return (
    &lt;BrowserRouter&gt;
      &lt;div className=&quot;App&quot;&gt;
        &lt;Routes&gt;
          &#123;/* 一级路由 */&#125;
          &#123;/* 当所有路径都没有匹配到时渲染此组件 作为兜底 */&#125;
          &lt;Route path='*' element=&#123;&lt;NotFound /&gt;&#125;&gt;&lt;/Route&gt;
        &lt;/Routes&gt;
      &lt;/div&gt;
    &lt;/BrowserRouter&gt;
  )
&#125;
 
export default App
</code></pre>
<h2 id="Redirect-重定向">Redirect (重定向)</h2>
<pre><code class="language-javascript">1.一般写在所有路由注册的最下方,当所有路由都无法匹配时,跳转到Redirect指定的路由**
2.具体编码:&lt;Routes&gt;
         	&lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
            &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;
            &lt;Redirect to=&quot;/about&quot;/&gt;
          &lt;/Routes&gt;

</code></pre>
<pre><code class="language-javascript">App.js代码修改

 &#123;/* 注册路由 路由组件写法 */&#125;
 &lt;Routes&gt;
 	&lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;
 	&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;
 	&lt;Redirect to=&quot;/about&quot;/&gt;
 &lt;/Routes&gt;
 
 记得引入
 import &#123; Route,Routes,Redirect &#125; from 'react-router-dom'

</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2024/01/24/Apifox%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Apifox的使用"><span class="has-text-weight-semibold">Next: Apifox的使用</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/MaggieMi"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> ami 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>