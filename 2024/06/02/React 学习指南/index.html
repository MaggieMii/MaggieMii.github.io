<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>React学习指南</title><meta name="description" content="逆风如解意，容易莫摧残"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="React 学习指南
初学者看这里
引子：React 与 Hyperapp
React 是 Facebook 于 2013 年开源的 JS 库，用于构建用户界面。这也是目前前端界最流行的 UI 基础库。
我们首先让大家接触 Hyperapp ，而不是直接学 React，就是因为 React 本身的设计思想，其实很简单。就是 UI = f(state)。而 Hyperapp 就是基于这个思想设计的简化版 React。
所以 React 相比 Hyperapp，更强大，适合真正的生产级别应用。但核心思想其实是一致的。懂了 Hyperapp，你可以很快上手 React。
React 的组件也是一个函数（React 16 之前只支持 Class 组件，不过目前我们一般都使用 React 16+，可以全盘使用函数式组.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">ami's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">React学习指南</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">React 学习指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%AD%A6%E8%80%85%E7%9C%8B%E8%BF%99%E9%87%8C"><span class="toc-text">初学者看这里</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AD%90%EF%BC%9AReact-%E4%B8%8E-Hyperapp"><span class="toc-text">引子：React 与 Hyperapp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99%E6%8E%A8%E8%8D%90"><span class="toc-text">学习材料推荐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%83%E4%B9%A0"><span class="toc-text">小练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9"><span class="toc-text">进阶内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7vs%E9%9D%9E%E5%8F%97%E6%8E%A7"><span class="toc-text">受控vs非受控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">受控组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">非受控组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Advanced-Topics"><span class="toc-text">Advanced Topics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ErrorBoundary"><span class="toc-text">ErrorBoundary</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C%E6%8D%95%E8%8E%B7%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF"><span class="toc-text">使用错误边界捕获渲染错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-react-error-boundary"><span class="toc-text">使用 react-error-boundary</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AHOC-renderProps"><span class="toc-text">设计模式：HOC + renderProps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#render-props%E6%A8%A1%E5%BC%8F"><span class="toc-text">render props模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#render-props-%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">render props 的特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">使用场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HOC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">HOC设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HOC%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">HOC的主要特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-text">使用场景：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-text">相同点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-text">不同点：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/React"><i class="tag post-item-tag">React</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">React学习指南</h1><time class="has-text-grey" datetime="2024-06-01T16:00:00.000Z">2024-06-02</time><article class="mt-2 post-content"><h1>React 学习指南</h1>
<h2 id="初学者看这里">初学者看这里</h2>
<h3 id="引子：React-与-Hyperapp">引子：React 与 Hyperapp</h3>
<p>React 是 Facebook 于 2013 年开源的 JS 库，用于构建用户界面。这也是目前前端界最流行的 UI 基础库。</p>
<p>我们首先让大家接触 Hyperapp ，而不是直接学 React，就是因为 React 本身的设计思想，其实很简单。就是 UI = f(state)。而 Hyperapp 就是基于这个思想设计的简化版 React。</p>
<p>所以 React 相比 Hyperapp，更强大，适合真正的生产级别应用。但核心思想其实是一致的。懂了 Hyperapp，你可以很快上手 React。</p>
<p>React 的组件也是一个函数（React 16 之前只支持 Class 组件，不过目前我们一般都使用 React 16+，可以全盘使用函数式组件）。函数返回的是 JSX 表示的虚拟 DOM 节点树，和 Hyperapp 一致。</p>
<p>但相比 Hyperapp，React 的每个组件都可以有自己的状态，而不是只有顶层的 App 才存储状态。</p>
<blockquote>
<p>React 可以通过 Redux 这样的状态管理工具去拥有全局状态，组件局部状态和全局状态可以混合使用。Redux 同样和 Hyperapp 的状态管理有相似之处。</p>
</blockquote>
<p>React 在函数式组件中的局部状态和副作用，是通过 Hook 来实现的。本身单纯的函数式组件是没有状态，也不能产生副作用的（比如发送网络请求），Hook 的出现改变了这一点。目前我们可以不用了解 Hook 具体的原理，只要掌握 Hook 的使用即可。</p>
<p>让我们来看一个简单的例子：</p>
<pre><code class="language-jsx">import React, &#123; useState &#125; from &quot;react&quot;;

function Example() &#123;
	const [count, setCount] = useState(0);

	return (
		&lt;div&gt;
			&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;
			&lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt;
		&lt;/div&gt;
	);
&#125;
</code></pre>
<p>Codepen 实例</p>
<p><code>useState</code> 是用于获取状态的 Hook。Hook 其实就是普通的函数调用。<code>useState</code> 调用之后会返回一个数组，第一项是状态的值，第二项是一个用来修改状态的函数。</p>
<p>我们只要记住，每次组件被调用，组件（函数）就会执行，然后 <code>useState</code> 就会被调用。调用之后就可以拿到最新的状态。</p>
<p>通过这个例子，我们就可以实现一个计数器，需要注意的是，React 的事件回调属性是驼峰的形式，并且回调只是普通的函数，里面可以执行任意逻辑，无需像 Hyperapp 那样返回新的 state。</p>
<p>此外 React 比起 Hyperapp 还有一些核心功能</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>支持合成事件，抹平了不同浏览器的事件兼容性</p>
</li>
<li class="lvl-2">
<p>内置了调度系统，会根据情况安排最合适的渲染时机，避免卡顿</p>
</li>
<li class="lvl-2">
<p>使用 fiber 架构，可以把组件的渲染工作拆分到多次完成，避免卡顿</p>
</li>
<li class="lvl-2">
<p>支持跨端，可以通过 React-native 编写 安卓/iOS/Web 三段通用的 App</p>
</li>
<li class="lvl-2">
<p>Context，Ref，Suspense，Fragment，Portal，各种 Hooks 等等多种多样的 API</p>
</li>
</ul>
<h3 id="学习材料推荐">学习材料推荐</h3>
<p>学 React 之前需要明确一点，React 在 16.8 版本推出了 Hooks。Hooks 让函数式组件可以拥有状态和副作用，而函数式组件相比 Class 组件更符合 UI = f(state) 的理念。因此目前我们编写的组件，都是用 Hooks 实现的。</p>
<p>但官网上的教程，大部分都是以 Class 组件为基础的。所以目前还没法避免接触 Class 组件，以后在历史项目中也可能会遇到。Class 组件其实也不难学。但大家要把重心放到函数组件上。</p>
<p>首先要看官方文档，这是免不了的。首先是 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hello-world.html">Main Concepts</a>。</p>
<ol>
<li class="lvl-3">
<p>了解基础： Props，State，组件定义，Class 组件声明周期，事件监听。</p>
</li>
<li class="lvl-3">
<p>了解如何编写条件渲染，列表渲染，关注 key 的作用。</p>
</li>
<li class="lvl-3">
<p>特别要关注：状态提升（Lifting State Up），组合 vs 继承（Composition vs Inheritance），受控组件 vs 非受控组件（Controlled Components vs Uncontrolled Components）</p>
</li>
</ol>
<p>然后是 Hooks，看官方的 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-intro.html">Hooks 教程</a>。useState 和 useEffect 是必须掌握的，其他的可以浏览一下。</p>
<p>之后就可以看一本完整的小册：<a target="_blank" rel="noopener" href="https://leanpub.com/the-road-to-learn-react-chinese/">The Way To React</a>。</p>
<blockquote>
<p>这本书是免费的，把价格拖到 0 就行。如果下载有问题，可以在组群反馈。</p>
</blockquote>
<p>这本书的食用方式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这本书用一个 Hacker News 程序员论坛的例子，贯穿全书，每一节后面都有源码链接，是在线的，可以看当前章节完成之后书本例子的代码。一定要结合代码看，最好可以自己在本地起一个项目，跟着写。</p>
</li>
<li class="lvl-2">
<p>每章结束后会有一些链接，主要是章节里提到的 JS 知识点，如果觉得有不懂的 JS 知识点，不妨先停下来复习一下。</p>
</li>
</ul>
<h3 id="小练习">小练习</h3>
<p>将 Class 组件实现的 <a target="_blank" rel="noopener" href="https://reactjs.org/tutorial/tutorial.html">React 官方教程</a> 改造为函数式组件（Hooks）版本。新建仓库 react-tutorial-hooks 并上传到 Github。</p>
<h2 id="进阶内容">进阶内容</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>受控 vs 非受控</p>
</li>
<li class="lvl-2">
<p>Advanced Topics</p>
</li>
<li class="lvl-2">
<p>ErrorBoundary</p>
</li>
<li class="lvl-2">
<p>设计模式：HOC + renderProps</p>
</li>
<li class="lvl-2">
<p>自定义 Hooks</p>
</li>
<li class="lvl-2">
<p>Suspense</p>
</li>
<li class="lvl-2">
<p>cocurrent</p>
</li>
<li class="lvl-2">
<p>rsc</p>
</li>
</ul>
<h3 id="受控vs非受控">受控vs非受控</h3>
<h4 id="受控组件">受控组件</h4>
<p>受控组件，指的是将表单元素的值交给组件的 state 来保存。</p>
<p>例子：</p>
<pre><code class="language-jsx">// import './styles.css'
import &#123; useState &#125; from 'react'

const App = () =&gt; &#123;
  const [val, setVal] = useState('muxi')

  const sumbit = () =&gt; &#123;
    // 直接拿组件 state
    const username = val
    // ...
  &#125;

  return (
    &lt;div&gt;
      用户名：
      &lt;input
        value=&#123;val&#125;
        onInput=&#123;(e) =&gt; &#123;
          setVal(e.target.value)
        &#125;&#125;
      /&gt;
      ...
    &lt;/div&gt;
  )
&#125;

export default App;

</code></pre>
<p>我们用 value prop 控制着 input 元素的值，当发生输入事件时，我们将新值赋值给 val，然后 val 再通过 value 强制更新到 input。</p>
<p>这种写法，可以<strong>让 state 一直保持和 input 的内容相同，我们可以直接读取 state，将其传递给其他地方，比如通过 redux 去传递。</strong></p>
<p><strong>缺点是会进行组件的更新，一般来说表单元素并不复杂，重渲染成本不高，可以忽略不计。</strong></p>
<h4 id="非受控组件">非受控组件</h4>
<p>非受控，就是指状态不由组件的 state 把持，而是让表单元素的内部控制着状态，在我们需要的时候再通过 <code>element.value</code> 的方式取出。</p>
<p>表单元素的初始值通过 defaultValue prop 来设置。</p>
<p>例子：</p>
<pre><code class="language-jsx">const App = () =&gt; &#123;
  const ref = useRef(null)
  const sumbit = () =&gt; &#123;
    // 通过元素的引用取值
    const username = ref.current?.value
    // ...
  &#125;

  return (
    &lt;div&gt;
      用户名：
      &lt;input ref=&#123;ref&#125; defaultValue=&quot;muxi&quot; /&gt;
      ...
    &lt;/div&gt;
  )
&#125;

</code></pre>
<p>优点是不会更新组件。缺点是不方便实时将值传给其他组件。</p>
<p>另外，它适合一种延迟更新状态的场景。比如输入一些内容，回车后失焦，发现格式不合法，就恢复为上一次的值。</p>
<h3 id="Advanced-Topics">Advanced Topics</h3>
<p>Advanced Topics，也就是一些高级的、不天天用的，但是需要我们会的一些知识点。</p>
<p><a target="_blank" rel="noopener" href="https://reactresources.com/topics/advanced-concepts">Advanced React Concepts | React Resources</a> 给出的Advanced Concepts:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Advanced Concepts</p>
<ul class="lvl-2">
<li class="lvl-4"><a target="_blank" rel="noopener" href="https://reactresources.com/topics/context">Context</a></li>
<li class="lvl-4"><a target="_blank" rel="noopener" href="https://reactresources.com/topics/error-boundaries">Error Boundaries</a></li>
<li class="lvl-4"><a target="_blank" rel="noopener" href="https://reactresources.com/topics/portals">Portals</a></li>
<li class="lvl-4"><a target="_blank" rel="noopener" href="https://reactresources.com/topics/higher-order-components">Higher Order Components</a></li>
<li class="lvl-4"><a target="_blank" rel="noopener" href="https://reactresources.com/topics/render-props">Render Props</a></li>
<li class="lvl-4">Concurrent Rendering
<ul class="lvl-4">
<li class="lvl-6"><a target="_blank" rel="noopener" href="https://reactresources.com/topics/time-slicing">Time Slicing</a></li>
<li class="lvl-6"><a target="_blank" rel="noopener" href="https://reactresources.com/topics/suspense">Suspense</a></li>
</ul>
</li>
<li class="lvl-4"><a target="_blank" rel="noopener" href="https://reactresources.com/topics/hooks">Hooks</a></li>
</ul>
</li>
</ul>
<h3 id="ErrorBoundary">ErrorBoundary</h3>
<h4 id="使用错误边界捕获渲染错误">使用错误边界捕获渲染错误</h4>
<p>React 中的错误边界是 <a target="_blank" rel="noopener" href="https://blog.logrocket.com/handling-javascript-errors-react-error-boundaries/">React 应用程序中错误处理的一个关键方面</a>。它们是 React 组件，用于捕获其子组件树中任何位置的 JavaScript 错误，记录这些错误，并显示回退 UI，而不是崩溃的组件树。它们就像一个 JavaScript 块，但用于组件。</p>
<p>React v16 中引入了错误边界，要使用它们，需要使用以下一种或两种<a target="_blank" rel="noopener" href="https://blog.logrocket.com/react-lifecycle-methods-tutorial-examples/">生命周期方法</a>定义类组件：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>getDerivedStateFromError()</code>：此生命周期方法在引发错误后呈现回退 UI。它是在渲染阶段调用的，因此不允许产生副作用</p>
</li>
<li class="lvl-2">
<p><code>componentDidCatch()</code>：此方法用于记录错误信息。它是在提交阶段调用的，因此允许副作用</p>
</li>
</ul>
<pre><code class="language-jsx">class ErrorBoundary extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123; hasError: false &#125;;
  &#125;

  static getDerivedStateFromError(error) &#123;
    // Update state so the next render will show the fallback UI.
    return &#123; hasError: true &#125;;
  &#125;

  componentDidCatch(error, errorInfo) &#123;
    // You can also log the error to an error reporting service
    console.log(error, errorInfo);
  &#125;

  render() &#123;
    if (this.state.hasError) &#123;
      // You can render any custom fallback UI
      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
    &#125;

    return this.props.children; //当没有错误发生时，正常渲染子组件
  &#125;
&#125;

// Usage in a component
class App extends React.Component &#123;
  render() &#123;
    return (
      &lt;ErrorBoundary&gt;
        &lt;MyComponent /&gt;
      &lt;/ErrorBoundary&gt;
    );
  &#125;
&#125;
</code></pre>
<pre><code class="language-jsx">//MyComponent
class MyComponent extends React.Component &#123;
  render() &#123;
    const dangerousOperation = null; // 故意设置为null以触发错误

    // 直接调用一个可能不存在的方法，这将在渲染时抛出错误
    dangerousOperation.doSomething();

    return (
      &lt;div&gt;
        &lt;h2&gt;My Component&lt;/h2&gt;
        &lt;p&gt;This is an example of a component that might error.&lt;/p&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;
</code></pre>
<h4 id="使用-react-error-boundary">使用 react-error-boundary</h4>
<p>虽然类组件及其生命周期方法可以帮助我们实现错误边界，但 <a target="_blank" rel="noopener" href="https://github.com/bvaughn/react-error-boundary">react-error-boundary</a> 是一个将此功能提升到新水平的库，使该过程更加简单和用户友好。这是一个小型库，提供了一种灵活的方式来处理 React 组件中的 JavaScript 错误。</p>
<p><strong>如何下载？</strong></p>
<pre><code>npm install react-error-boundary
</code></pre>
<p>React-error-boundary 使用更现代的方法与 <a target="_blank" rel="noopener" href="https://blog.logrocket.com/react-hooks-cheat-sheet-solutions-common-problems/">React Hooks</a> 和功能组件，这更符合 React 开发的当前趋势。它使用一个名为<code>ErrorBoundary</code>的简单组件，您可以使用该组件来包装可能容易出错的代码。</p>
<p>该库提供的组件有一个名为 <code>fallbackRender</code> 的 prop，它接受一个函数或一个 React 元素，以便在捕获错误时显示。此外，它还提供了一个道具，可用于在某些道具更改时重置组件的状态。<code>ErrorBoundary``fallbackUI``resetKeys</code></p>
<p>react-error-boundary 的美妙之处在于它消除了手动编写类组件和处理状态的需要。它在幕后完成所有繁重的工作，使开发人员能够专注于构建他们的应用程序。让我们看一个如何在组件中使用 react-error-boundary 的例子：</p>
<pre><code class="language-jsx">import &#123; ErrorBoundary &#125; from 'react-error-boundary'

function MyFallbackComponent(&#123; error, resetErrorBoundary &#125;) &#123;
  return (
    &lt;div role=&quot;alert&quot;&gt;
      &lt;p&gt;Something went wrong:&lt;/p&gt;
      &lt;pre&gt;&#123;error.message&#125;&lt;/pre&gt;
      &lt;button onClick=&#123;resetErrorBoundary&#125;&gt;Try again&lt;/button&gt;
    &lt;/div&gt;
  )
&#125;

function MyComponent() &#123;
  // Some component logic that may throw JS errors
&#125;

function App() &#123;
  return (
    &lt;ErrorBoundary
      FallbackComponent=&#123;MyFallbackComponent&#125;
      onReset=&#123;() =&gt; &#123;
        // reset the state of your app here
      &#125;&#125;
      resetKeys=&#123;['someKey']&#125;
    &gt;
      &lt;MyComponent /&gt;
    &lt;/ErrorBoundary&gt;
  )
&#125;
</code></pre>
<p>参考文档：<a target="_blank" rel="noopener" href="https://blog.logrocket.com/react-error-handling-with-react-error-boundary/">使用 react-error-boundary 处理 React 错误 - LogRocket 博客</a></p>
<h3 id="设计模式：HOC-renderProps">设计模式：HOC + renderProps</h3>
<h4 id="render-props模式">render props模式</h4>
<p><code>render props</code> 是一种在React组件之间传递一个名为 <code>render</code> 的函数的模式，这个函数返回一个React元素。<code>render props</code> 模式允许组件通过其props接收一个函数，该函数负责决定组件如何渲染。这种方法提供了一种高度灵活的方式来构建可重用的组件。</p>
<h5 id="示例：">示例：</h5>
<p>假设我们有一个 <code>Button</code> 组件，我们想要根据不同的条件渲染不同的按钮样式或行为：</p>
<pre><code class="language-jsx">// ButtonWithRenderProp.js
import React from 'react';

const ButtonWithRenderProp = (&#123; render &#125;) =&gt; &#123;
  const onClick = () =&gt; &#123;
    console.log('Button clicked!');
  &#125;;

  return (
    &lt;div&gt;
      &#123;render(&#123; onClick &#125;)&#125;
    &lt;/div&gt;
  );
&#125;;

export default ButtonWithRenderProp;
</code></pre>
<p>现在，我们可以这样使用这个组件：</p>
<pre><code class="language-jsx">// App.js
import React from 'react';
import ButtonWithRenderProp from './ButtonWithRenderProp';

const App = () =&gt; &#123;
  return (
    &lt;ButtonWithRenderProp
      render=&#123;(&#123; onClick &#125;) =&gt; (
        &lt;button onClick=&#123;onClick&#125; style=&#123;&#123; background: 'blue', color: 'white' &#125;&#125;&gt;
          Click me!
        &lt;/button&gt;
      )&#125;
    /&gt;
  );
&#125;;

export default App;
</code></pre>
<p>在这个例子中，<code>ButtonWithRenderProp</code> 组件接收一个 <code>render</code> 函数作为prop，这个函数接收一个对象，其中包含一个 <code>onClick</code> 函数。然后，<code>render</code> 函数返回一个按钮元素，它使用传递进来的 <code>onClick</code> 函数。</p>
<h5 id="render-props-的特点："><code>render props</code> 的特点：</h5>
<ol>
<li class="lvl-3">
<p><strong>动态渲染</strong>：组件可以动态决定如何渲染，基于传递给它的 <code>render</code> 函数。</p>
</li>
<li class="lvl-3">
<p><strong>解耦组件</strong>：<code>render props</code> 允许你将组件的行为（通过 <code>render</code> 函数）与其结构（组件本身的JSX）解耦。</p>
</li>
<li class="lvl-3">
<p><strong>可组合性</strong>：使用 <code>render props</code>，你可以轻松地组合多个组件，每个组件都可以贡献一部分渲染逻辑。</p>
</li>
</ol>
<h5 id="使用场景：">使用场景：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>动态组件</strong>：当你需要基于某些条件渲染不同的组件时。</p>
</li>
<li class="lvl-2">
<p><strong>抽象UI</strong>：当你想要创建一个组件，它可以适应多种不同的渲染需求时。</p>
</li>
<li class="lvl-2">
<p><strong>传递行为</strong>：当你想要将渲染逻辑作为props传递给子组件时。</p>
</li>
</ul>
<p>render props模式最重要的是它返回一个react元素，比如我将上面的render属性改名，依然有效。</p>
<pre><code class="language-js">import React from 'react';

const SharedComponentWithGoofyName extends React.Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        &#123;this.props.wrapThisThingInADiv()&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;

const SayHelloWithGoofyName = () =&gt; (
  &lt;SharedComponentWithGoofyName wrapThisThingInADiv=&#123;() =&gt; (
    &lt;span&gt;hello!&lt;/span&gt;
  )&#125; /&gt;
);
</code></pre>
<h4 id="HOC设计模式">HOC设计模式</h4>
<p>高阶组件（Higher Order Component，HOC）是React中用于重用组件逻辑的一种高级技术。它本身不是一个React组件，而是<strong>一个函数，这个函数接受一个组件作为参数，并返回一个新的组件</strong>。HOC让你能够重用组件之间的代码，如事件处理、订阅数据源、注入主题等，而不必在每个组件中重复这些代码。</p>
<blockquote>
<p>高阶组件在React生态链技术中经常用到，对读者较为熟悉的,比如Redux中的connect，React Router中的withRouter等。</p>
</blockquote>
<h5 id="HOC的主要特点：">HOC的主要特点：</h5>
<ol>
<li class="lvl-3">
<p><strong>参数传递</strong>：HOC接收一个组件作为参数。</p>
</li>
<li class="lvl-3">
<p><strong>返回组件</strong>：HOC返回一个新的组件。</p>
</li>
<li class="lvl-3">
<p><strong>可重用性</strong>：通过HOC，你可以创建可重用的组件逻辑。</p>
</li>
<li class="lvl-3">
<p><strong>无侵入性</strong>：HOC不会修改传入的组件，也不会使用继承，因此它们可以更容易地进行测试，并且可以保持干净。</p>
</li>
</ol>
<h5 id="使用场景：-2">使用场景：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>代码复用</strong>：当多个组件需要相同的功能时，可以使用HOC来避免重复代码。</p>
</li>
<li class="lvl-2">
<p><strong>动态props注入</strong>：HOC可以添加新的props到组件，或者修改传递给子组件的props。</p>
</li>
<li class="lvl-2">
<p><strong>渲染劫持</strong>：HOC可以在渲染组件之前或之后执行操作。</p>
</li>
<li class="lvl-2">
<p><strong>关注点分离</strong>：将组件的业务逻辑和UI分离，使得组件更加专注于UI的展示。</p>
</li>
</ul>
<h5 id="代码示例">代码示例</h5>
<pre><code class="language-jsx">import React from 'react';

// 假设的认证服务，用于模拟检查登录状态
const AuthService = &#123;
  isAuthenticated: () =&gt; &#123;
    // 这里可以是异步操作，比如从localStorage获取token，然后验证token的有效性
    // 模拟检查localStorage中是否有token
    const token = localStorage.getItem('userToken');
    return !!token; // 如果有token，返回true，表示用户已登录
  &#125;
&#125;;

function withAuth(WrappedComponent) &#123;
  return class extends React.Component &#123;
    render() &#123;
      const isLoggedIn = AuthService.isAuthenticated();

      return &lt;WrappedComponent isLoggedIn=&#123;isLoggedIn&#125; &#123;...this.props&#125; /&gt;;
    &#125;
  &#125;;
&#125;

// 示例组件，使用HOC注入的isLoggedIn prop
class SomeComponent extends React.Component &#123;
  render() &#123;
    const &#123; isLoggedIn &#125; = this.props;
    if (isLoggedIn) &#123;
      return &lt;div&gt;Welcome, you are logged in!&lt;/div&gt;;
    &#125; else &#123;
      return &lt;div&gt;Please log in to continue.&lt;/div&gt;;
    &#125;
  &#125;
&#125;

const AuthenticatedComponent = withAuth(SomeComponent);

export default AuthenticatedComponent;
</code></pre>
<h5 id="相同点：">相同点：</h5>
<ol>
<li class="lvl-3">
<p>组件复用：HOC和Render Props都是用于实现组件复用的技术，使得我们可以在多个组件之间共享功能。</p>
</li>
<li class="lvl-3">
<p>非侵入性：它们都是以非侵入性的方式添加功能到现有组件，不需要修改原始组件的代码。</p>
</li>
</ol>
<h5 id="不同点：">不同点：</h5>
<ol>
<li class="lvl-3">
<p>抽象层级：HOC是一种在React中复用组件逻辑的高级技术。它实际上是一个函数，接受一个组件作为参数，并返回一个新的组件。这种方式可以使得组件逻辑与原始组件解耦，但可能会产生嵌套层级。<br>
Render Props是通过props将一个函数传递给组件，这个函数允许组件在渲染时获取到特定的数据或行为。这样可以更加灵活地控制组件的行为。</p>
</li>
<li class="lvl-3">
<p>组件结构：使用HOC时，我们在组件之外创建一个包裹组件，它会对原始组件进行包装，从而添加额外的功能。这意味着我们需要编写一个高阶函数来创建新的组件。使用Render Props时，我们在组件内部定义一个特定的prop，它是一个函数，用于传递所需的功能或数据。这种方式更加直接，不需要额外的高阶函数。</p>
</li>
<li class="lvl-3">
<p>数据流：HOC可以通过props将数据传递给被包装的组件，但它不能直接访问被包装组件的state。在HOC中，数据流是从外部向内部。<br>
Render Props允许组件在渲染过程中向内部传递数据，通常是通过props中的回调函数。在Render Props中，数据流是从内部向外部。</p>
</li>
</ol>
<h2 id="原理">原理</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>基本流程</p>
</li>
<li class="lvl-2">
<p>合成事件</p>
</li>
<li class="lvl-2">
<p>fiber</p>
</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2024/03/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" title="浏览器输入URL后发生了什么"><span class="has-text-weight-semibold">Next: 浏览器输入URL后发生了什么</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/MaggieMi"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> ami 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>